<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zero&#39;s Blog</title>
  <subtitle>点滴分享 多彩生活</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://czero000.github.io/"/>
  <updated>2016-10-20T02:47:23.146Z</updated>
  <id>http://czero000.github.io/</id>
  
  <author>
    <name>C.c</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Dockerfile创建blog</title>
    <link href="http://czero000.github.io/2016/10/20/docker-blog.html"/>
    <id>http://czero000.github.io/2016/10/20/docker-blog.html</id>
    <published>2016-10-20T02:45:00.000Z</published>
    <updated>2016-10-20T02:47:23.146Z</updated>
    
    <content type="html"><![CDATA[<p>Docker 是一个有趣的技术，在过去的两年已经从一个想法变成了全世界的机构都在采用来部署应用的技术。下面会通过 docker 来创建一个blog。</p>
<h1 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h1><p>Docker 是一个操作系统容器管理工具，通过将应用打包到操作系统容器里面，从而让你能轻松管理和部署应用。</p>
<h1 id="容器-vs-虚拟机"><a href="#容器-vs-虚拟机" class="headerlink" title="容器 vs 虚拟机"></a>容器 vs 虚拟机</h1><p>容器可能不如虚拟机一样为人所熟知，但是它们是另外的一种提供操作系统虚拟化的方法。然而，他们与标准的虚拟机有很大的差异。</p>
<p>标准的虚拟机通常包含一个完整的操作系统，OS 软件包，最后包含一两个应用。它是通过一个向虚拟机提供了硬件虚拟化的 Hypervisor 来实现的，允许单个服务器运行很多独立的被当做虚拟游客（virtual guest）的操作系统。</p>
<p>而容器与虚拟机的类似之处在于它们允许单个服务器运行多个操作环境（operating environment），然而这些环境不却是完整的操作系统。容器通常只包含必要的 OS 软件包和应用。他们通常不包含一个完整的操作系统或者硬件虚拟化。这也意味着比之虚拟机，容器的额外开销（overhead）更小。</p>
<p>容器和虚拟机通常被视为不能共生的技术，然而这通常是一个误解。虚拟机面向物理服务器，提供可以能与其他虚拟机一起共享这些物理资源的，功能完善的操作环境。容器通常是用来通过对单一主机的一个进程进行隔离，来保证被隔离的进程无法与处于同一个系统的其他进程进行互动。实际上，比起完全的虚拟机，容器与 BSD 的 Jail，chroot 的进程更加类似。</p>
<h1 id="Docker-提供了什么"><a href="#Docker-提供了什么" class="headerlink" title="Docker 提供了什么"></a>Docker 提供了什么</h1><p>Docker自身并不是一个容器的运行时环境；实际上 Docker 实际上是对容器技术不可知的（container technology agnostic），并且为了支持Solaris Zones和 BSD Jails 花了不少功夫。Docker 提供的是一种容器管理，打包和部署的方法。尽管这种类型的功能已经某一种程度地存在于虚拟机中，但在传统上，它们并不是为了绝大多数的容器方案而生的，而那些已经存在的，却又不如 Docker 一样容易使用且功能完善。</p>
<h1 id="通过-Dockerfile-方式部署一个-blog-转载"><a href="#通过-Dockerfile-方式部署一个-blog-转载" class="headerlink" title="通过 Dockerfile 方式部署一个 blog (转载)"></a>通过 Dockerfile 方式部署一个 blog (转载)</h1><ul>
<li>获取 blog 源码</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/madflojo/blog.git</div><div class="line">cd blog</div></pre></td></tr></table></figure>
<ul>
<li>使用 FROM 继承一个 docker 镜像<br>Dockerfile的第一条命令是 <code>FROM</code> 指令。这用来将存在的 Docker 镜像指定为基础镜像，这会让docker 使用 nginx 镜像。如果想使用最原始的空白状态。可以制定 <code>ubuntu:latest</code>使用 ubuntu 镜像。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FROM nginx:latest</div><div class="line">MAINTAINER Charlie.Cui &lt;charlie.cui127@mail.com&gt;</div></pre></td></tr></table></figure>
<p>除了使用 <code>FROM</code> 指令，还使用了 <code>MAINTAINER</code> 指令，用来显示 Dockerfile 的作者。Docker支持使用 <code>#</code> 用来当做注释的标示。</p>
<ul>
<li>使用 <code>RUN</code> 来执行 <code>apt-get</code></li>
</ul>
<p>如果需要在 <code>docker</code> 中执行 <code>apt update</code> 和 <code>apt install python-dev</code>，可以通过 <code>RUN</code> 指令来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">FROM nginx:latest</div><div class="line">MAINTAINER Charlie.Cui &lt;charlie.cui127@mail.com&gt;</div><div class="line"></div><div class="line">RUN apt -qq update</div><div class="line">RUN apt -qqy install python-dev python-pip</div></pre></td></tr></table></figure></p>
<ul>
<li>安装 python 模块</li>
</ul>
<p>如果需要安装 python 模块，在 docker 之外，可以使用 pip 命令完成并且引用在仓库中的一个名叫<code>requirements.txt</code>文件。Dockerfile 使用 <code>COPY</code> 指令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">FROM nginx:latest</div><div class="line">MAINTAINER Charlie.Cui &lt;charlie.cui127@mail.com&gt;</div><div class="line"></div><div class="line">RUN apt -qq update</div><div class="line">RUN apt -qqy install python-dev python-pip</div><div class="line"></div><div class="line">RUN mkdir -p /build/</div><div class="line">COPY requirements.txt /build/</div><div class="line">RUN pip install -r /build/requirements.txt</div></pre></td></tr></table></figure></p>
<ul>
<li>构建容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker build -t blog:v1 .</div></pre></td></tr></table></figure>
<p>使用 <code>-t</code> 表示来讲这个镜像打上 blog 标签</p>
<ul>
<li>Docker 构建缓存</li>
</ul>
<p>当docker 构建一个镜像的时候，不仅仅构建一个单一的镜像，它实际上在整个构建过程中构建多个镜像。每进行一步会构建一个镜像，当构建相同的容器时，会使用已经缓存的镜像，而不是重新构建一个镜像。凡是都会有两面，好的一面是当应用场景是 copy 文件，当源文件被更改，再次运行时 docker 会检测到文件不同，会从新 copy 新的文件，但是如果是安装 python-dev 这个软件包，当仓库更新了软件包版本，docker 是没法检测到这个变化，会傻傻的使用缓存，这样就会安装了一个老版本的软件。解决这个需要在 docker 构建时制定 <code>--no-cache=True</code> 来禁用缓存</p>
<ul>
<li>部署 blog 其余部分</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">FROM nginx:latest</div><div class="line">MAINTAINER Charlie.Cui &lt;charlie.cui127@mail.com&gt;</div><div class="line"></div><div class="line">RUN apt -qq update</div><div class="line">RUN apt -qqy install python-dev python-pip</div><div class="line"></div><div class="line">RUN mkdir -p /build/</div><div class="line">COPY requirements.txt /build/</div><div class="line">RUN pip install -r /build/requirements.txt</div><div class="line"></div><div class="line">COPY static /build/static</div><div class="line">COPY templates /build/templates</div><div class="line">COPY hamerkop /build/</div><div class="line">COPY config.yml /build/</div><div class="line">COPY articles /build/articles</div><div class="line"></div><div class="line">RUN /build/hamerkop -c /build/config.yml</div></pre></td></tr></table></figure>
<p>当再次运行 <code>docker build -t blog:v1 .</code>来构建 docker 镜像</p>
<ul>
<li>运行一个定制化的容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -d -p 80:80 --name=blog blog:v1</div></pre></td></tr></table></figure>
<p>使用<code>-p</code>参数，可以标志让用户将一个端口从主机映射到容器的一个端口，</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Docker 是一个有趣的技术，在过去的两年已经从一个想法变成了全世界的机构都在采用来部署应用的技术。下面会通过 docker 来创建一个blog。&lt;/p&gt;
&lt;h1 id=&quot;什么是-Docker&quot;&gt;&lt;a href=&quot;#什么是-Docker&quot; class=&quot;headerlin
    
    </summary>
    
      <category term="运维技术" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Docker" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/Docker/"/>
    
    
      <category term="docker" scheme="http://czero000.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker镜像</title>
    <link href="http://czero000.github.io/2016/10/20/docker-images.html"/>
    <id>http://czero000.github.io/2016/10/20/docker-images.html</id>
    <published>2016-10-20T02:44:48.000Z</published>
    <updated>2016-10-20T02:46:38.242Z</updated>
    
    <content type="html"><![CDATA[<h1 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h1><h2 id="什么是镜像"><a href="#什么是镜像" class="headerlink" title="什么是镜像"></a>什么是镜像</h2><ul>
<li>镜像是 Docker 的三大组件之一</li>
<li>Docker 镜像就是一个只读模版，一个镜像可以包含一个完整的ubuntu 操作系统，系统安装了 apache 和用户自定义应用软件。</li>
<li>镜像可以用来创建容器，Docker 提供了一个简单的机制来创建镜像或者更新现有镜像，用户甚至可以直接从其他人哪里下载已经做好的镜像来使用</li>
<li>Docker 运行容器之前需要本地存在对应镜像，如果不存在，Docker 就会从镜像仓库下载(默认是 Docker Hub 公共注册服务器的仓库)</li>
</ul>
<h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>通过 <code>docker pull</code> 命令从仓库下载所需的镜像，镜像可以通过 <code>Docker Hub</code> 获取已有镜像并更新，也可以利用本地文件系统创建一个<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">\\下载一个ubuntu16.04操作系统镜像</div><div class="line"> docker pull ubuntu:16.04</div></pre></td></tr></table></figure></p>
<p>该命令实际上是<code>docker pull registry.hub.docker.com/ubuntu:16.04</code>命令，即从注册服务器<code>registry.hub.docker.com</code>中的<code>ubuntu</code>仓库下载标记为16.04的镜像<br>有的时候官方注册服务器下载较慢，可以从其他仓库下载，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker pull somedomain:5000/ubuntu:16.04</div></pre></td></tr></table></figure></p>
<h2 id="列出当前镜像"><a href="#列出当前镜像" class="headerlink" title="列出当前镜像"></a>列出当前镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker images           </div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</div><div class="line">ubuntu              16.04               c73a085dc378        2 weeks ago         127.1 MB</div></pre></td></tr></table></figure>
<p>在列出的信息中，可以看到几个字段的信息</p>
<ul>
<li>来自那个仓库 -&gt; ubuntu</li>
<li>镜像的标记   -&gt; latest、16.04</li>
<li>ID         -&gt; 唯一</li>
<li>创建时间</li>
<li>镜像大小<br><code>TAG</code>信息标记来自同一个仓库的不同镜像，例如<code>ubuntu</code>仓库有多个镜像，通过TAG信息区分放行版本，例如，10.04、12.04、12.10等。通过下面命令指定镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">\\ 通过ubuntu:16.04 启动一个容器</div><div class="line">docker run -t -i ubuntu:16.04 /bin/bash</div></pre></td></tr></table></figure>
<p>如果不执行 <code>TAG</code>，则默认使用 <code>latest</code> 标记信息</p>
<h2 id="修改已有镜像"><a href="#修改已有镜像" class="headerlink" title="修改已有镜像"></a>修改已有镜像</h2><ul>
<li>利用镜像启动一个容器<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name docker_test -i -t -d ubuntu:16.04 /bin/bash</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在容器中添加vim软件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt install -y vim</div></pre></td></tr></table></figure></p>
<p>当结束后，使用<code>exit</code>退出，现在容器被改变了，使用docker commit命令提交更新后的副本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">docker commit -m &quot;Added Vim&quot; -a &quot;charlie.cui&quot; 50eabeaf73f6 ubuntu:16.04v2</div><div class="line">325a4e26e96fdefb70a9941db1c19ead801cf3ac5d9228bca6fc6c1a13c0ab92</div></pre></td></tr></table></figure></p>
<ul>
<li><code>-m</code> 来指定提交的说明信息,与使用版本控制工具一样</li>
<li><code>-a</code> 可以指定更新的用户信息</li>
<li>容器ID</li>
<li>指定目标镜像仓库名和tag信息<br>成功创建之后便会返回镜像的ID信息</li>
</ul>
<p>使用 <code>docker images</code> 来查看新创建的镜像</p>
<p>之后便可以使用新的镜像启动容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -t -i ubuntu:16.04v2 /bin/bash</div></pre></td></tr></table></figure></p>
<h3 id="利用-Dockerfile-来创建镜像"><a href="#利用-Dockerfile-来创建镜像" class="headerlink" title="利用 Dockerfile 来创建镜像"></a>利用 Dockerfile 来创建镜像</h3><p>使用 <code>docker commit</code> 来扩展一个镜像相对简单，但是不方便在一个团队中分享。可以使用 <code>docker build</code> 来创建一个新的镜像，首先需要创建一个 Dockerfile ，包含一些如何创建镜像的指令</p>
<ul>
<li>新建一个目录和一个 Dockerfile</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir docker</div><div class="line">cd docker/</div><div class="line">touch Dockerfile</div></pre></td></tr></table></figure>
<ul>
<li>Dockerfile 中每一条指令都创建镜像的一层<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cat Dockerfile</div><div class="line">#This is a comment</div><div class="line">FROM ubuntu:16.04</div><div class="line">MAINTAINER Charlie.Cui &lt; charlie.cui127@gmail.com &gt; </div><div class="line">RUN apt-get -qq update</div><div class="line">RUN apt-get -qqy install vim</div></pre></td></tr></table></figure>
</li>
</ul>
<p>Dockerfile 的基本语法</p>
<ul>
<li>使用#来注释</li>
<li><code>FROM</code>指令告诉Docker使用哪个镜像作为基础镜像</li>
<li>接着为维护者信息</li>
<li><code>RUN</code>开头的指令会在创建中运行，比如安装一个软件包，在这里使用<code>apt-get</code>安装vim</li>
</ul>
<p>编写 Dockerfile 之后，可以使用 <code>docker build</code> 来生成镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">docker build -t &quot;ubuntu16.04:v1&quot; . </div><div class="line">Sending build context to Docker daemon 3.072 kB</div><div class="line">Step 1 : FROM ubuntu:16.04</div><div class="line"> ---&gt; e9ae3c220b23</div><div class="line">Step 2 : MAINTAINER Charlie.Cui </div><div class="line"> ---&gt; Using cache</div><div class="line"> ---&gt; 16d77dc9a444</div><div class="line">Step 3 : RUN apt-get -y -qq update</div><div class="line"> ---&gt; Running in b8407b9d75c4</div><div class="line"> ---&gt; 8721117f7c1f</div><div class="line">...</div><div class="line">Processing triggers for libc-bin (2.19-0ubuntu6.6) ...</div><div class="line"> ---&gt; 5a4b35abd4c4</div><div class="line">Removing intermediate container bb09f1a73b30</div><div class="line">Successfully built 5a4b35abd4c4</div></pre></td></tr></table></figure></p>
<p>其中 <code>-t</code> 标记添加 tag，指定新的镜像用户信息。 <code>.</code>是 Dockerfile 所在的路径(当前目录)，也可以使用一个具体的 Dockerfile 路径</p>
<p>上面的过程可以看到 build 进程在执行操作。它所做的第一件事就是上传 Dockerfile 内容，应为所有的操作都是根据 Dockerfile 内容来执行。<br>然后，Dockfile 中的指令被一条一条的执行，每一步都创建了一个新的容器，在容器中执行指令并提交修改(跟 docker commit 命令一样)。当所有的指令执行之后，返回最终的镜像 ID，所有的中间步骤产生的容器都被清理掉。</p>
<p><strong>注： Dockerfile 中执行命令不能超过127</strong></p>
<p>此外，还可以利用 ADD 命令赋值本地文件到镜像；用 <code>EXPOSE</code> 命令向外部开放端口；用 <code>CMD</code> 命令来描述容器启动后运行的程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ADD myApp /var/www</div><div class="line">EXPOSE 80</div><div class="line">CMD [&quot;/usr/sbin/apachectl&quot;, &quot;-d&quot;, &quot;FOREGROUND&quot;]</div></pre></td></tr></table></figure></p>
<p>现在可以利用新创建的镜像启动一个容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker]# docker run -t -i ubuntu16.04:v1 /bin/bash</div></pre></td></tr></table></figure></p>
<p>还可以用 <code>docker tag</code>命令修改镜像标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker tag 5a4b35abd4c4 ubuntu16.04:devel</div></pre></td></tr></table></figure></p>
<h3 id="本地文件系统导入"><a href="#本地文件系统导入" class="headerlink" title="本地文件系统导入"></a>本地文件系统导入</h3><p>要从本地文件系统导入一个镜像，可以使用openvz的模版来创建：openvz的模版下载地址：<a href="http://openvz.org/Download/templates/precreated" target="_blank" rel="external">http://openvz.org/Download/templates/precreated</a></p>
<p>下载一个centos-7-x86_64的镜像，使用下面命令导入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget http://download.openvz.org/template/precreated/centos-7-x86_64.tar.gz</div><div class="line">cat centos-7-x86_64.tar.gz | docker import - centos:7</div><div class="line">45a9c0d13bd2d94a69f8a70501541f5329dbbc4760e610013a801d8e11d8cb46</div></pre></td></tr></table></figure></p>
<p>查看导入的新镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker images</div><div class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             VIRTUAL SIZE</div><div class="line">centos              7                   45a9c0d13bd2        7 minutes ago       564.3 MB</div></pre></td></tr></table></figure></p>
<h3 id="存出镜像"><a href="#存出镜像" class="headerlink" title="存出镜像"></a>存出镜像</h3><p>如果想要导出镜像到本地文件，可以使用<code>docker save</code>命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">\\ 保存镜像到本地文件</div><div class="line">docker save -o ubuntu_16.04.tar ubuntu:16.04</div></pre></td></tr></table></figure></p>
<h3 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h3><p>可以使用<code>docker load</code>从导出的本地文件在导入到本地镜像库,命令会导入镜像以及其他的元数据信息(标签等)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker load --input ubuntu_16.04.tar</div><div class="line">或者</div><div class="line">docker load &lt; ubuntu_16.04.tar</div></pre></td></tr></table></figure></p>
<h4 id="移除本地镜像"><a href="#移除本地镜像" class="headerlink" title="移除本地镜像"></a>移除本地镜像</h4><p>如果要移除本地镜像，使用<code>docker rmi</code>命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">dock rmi ubuntu:16.04</div></pre></td></tr></table></figure></p>
<p><strong><em> 在删除镜像之前要先<code>docker rm</code>删除掉依赖于这个镜像的容器 </em></strong></p>
<h3 id="清理所有为打过标签的本地镜像"><a href="#清理所有为打过标签的本地镜像" class="headerlink" title="清理所有为打过标签的本地镜像"></a>清理所有为打过标签的本地镜像</h3><p><code>docker images</code> 可以列出本地的所有镜像，其中有很多中间状态的未打过标签的镜像，大量占用磁盘空间，使用下面命令清理本地镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker rmi $(docker images -q -f &quot;dangling=true&quot;)</div><div class="line"></div><div class="line">\\ 完整写法</div><div class="line">docker rmi $(docker images --quiet --filter &quot;dangling=true&quot;)</div></pre></td></tr></table></figure>
<h3 id="镜像的实现原理"><a href="#镜像的实现原理" class="headerlink" title="镜像的实现原理"></a>镜像的实现原理</h3><blockquote>
<p>Docker 镜像是怎么实现增量的修改和维护的？ 每个镜像都由很多层次构成，Docker 使用 Union FS 将这<br>些不同的层结合到一个镜像中去。<br>通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个 disk 挂到同一个目录下,另一个更<br>常用的就是将一个只读的分支和一个可写的分支联合在一起，Live CD 正是基于此方法可以允许在镜像不<br>变的基础上允许用户在其上进行一些写操作。 Docker 在 AUFS 上构建的容器也是利用了类似的原理。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;镜像&quot;&gt;&lt;a href=&quot;#镜像&quot; class=&quot;headerlink&quot; title=&quot;镜像&quot;&gt;&lt;/a&gt;镜像&lt;/h1&gt;&lt;h2 id=&quot;什么是镜像&quot;&gt;&lt;a href=&quot;#什么是镜像&quot; class=&quot;headerlink&quot; title=&quot;什么是镜像&quot;&gt;&lt;/a&gt;什么是镜
    
    </summary>
    
      <category term="运维技术" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Docker" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/Docker/"/>
    
    
      <category term="docker" scheme="http://czero000.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门介绍</title>
    <link href="http://czero000.github.io/2016/10/20/rudiments-of-docker.html"/>
    <id>http://czero000.github.io/2016/10/20/rudiments-of-docker.html</id>
    <published>2016-10-20T02:43:29.000Z</published>
    <updated>2016-10-20T02:46:02.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-简介"><a href="#Docker-简介" class="headerlink" title="Docker 简介"></a>Docker 简介</h1><h2 id="Docker-是什么"><a href="#Docker-是什么" class="headerlink" title="Docker 是什么"></a>Docker 是什么</h2><blockquote>
<p>Docker is an open-source engine that automates the deployment of any application as a lightweight, portable, self-sufficient container that will run virtually anywhere.</p>
</blockquote>
<p>Docker[<a href="https://www.docker.com/" target="_blank" rel="external">https://www.docker.com/</a>] 是 PaaS 提供商 <a href="https://www.dotcloud.com/" target="_blank" rel="external">dotCloud</a> 开源的一个基于 LXC 的高级容器引擎， <a href="https://github.com/docker/docker" target="_blank" rel="external">]源代码</a>托管在 <a href="https://www.github.com" target="_blank" rel="external">Github</a> 上, 基于go语言并遵从Apache2.0协议开源。Docker近期非常火热，无论是从 GitHub 上的代码活跃度，还是Redhat宣布在 <a href="http://server.cnw.com.cn/server-os/htm2014/20140616_303249.shtml" target="_blank" rel="external">RHEL7中正式支持Docker</a>，都给业界一个信号，这是一项创新型的技术解决方案。就连 Google 公司的 Compute Engine 也支持 docker 在其之上运行，国内 “BAT” 先锋企业百度 Baidu App Engine(BAE) 平台也是<a href="http://blog.docker.com/2013/12/baidu-using-docker-for-its-paas/" target="_blank" rel="external">以Docker作为其PaaS云基础</a>。</p>
<p>Docker产生的目的就是为了解决以下问题：</p>
<ol>
<li><p>环境管理复杂：从各种 OS 到各种中间件再到各种 App，一款产品能够成功发布，作为开发者需要关心的东西太多，且难于管理，这个问题在软件行业中普遍存在并需要直接面对。Docker可以简化部署多种应用实例工作，比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个 Image 部署。</p>
</li>
<li><p>云计算时代的到来：AWS 的成功，引导开发者将应用转移到云上, 解决了硬件管理的问题，然而软件配置和管理相关的问题依然存在 (AWS cloudformation是这个方向的业界标准, 样例模板可参考这里)。Docker 的出现正好能帮助软件开发者开阔思路，尝试新的软件管理方法来解决这个问题。</p>
</li>
<li><p>虚拟化手段的变化：云时代采用标配硬件来降低成本，采用虚拟化手段来满足用户按需分配的资源需求以及保证可用性和隔离性。然而无论是 KVM 还是 Xen，在 Docker 看来都在浪费资源，因为用户需要的是高效运行环境而非OS，GuestOS 既浪费资源又难于管理，更加轻量级的 LXC 更加灵活和快速。<br><img src="http://czero000.github.io/images/docker/vm.png" alt="vm"><br><img src="http://czero000.github.io/images/docker/docker.png" alt="docker"></p>
</li>
<li><p>LXC 的便携性：LXC 在 Linux 2.6 的 Kernel 里就已经存在了，但是其设计之初并非为云计算考虑的，缺少标准化的描述手段和容器的可便携性，决定其构建出的环境难于分发和标准化管理(相对于 KVM 之类 image 和 snapshot 的概念)。Docker 就在这个问题上做出了实质性的创新方法。</p>
</li>
</ol>
<h2 id="Docker的主要特性"><a href="#Docker的主要特性" class="headerlink" title="Docker的主要特性"></a>Docker的主要特性</h2><ul>
<li>文件系统隔离： 每个进程容器运行在完全独立的根文件系统里。</li>
<li>资源隔离： 可以使用 cgroup 为每个进程容器分配不同的系统资源，例如 CPU 和内存。</li>
<li>网络隔离： 每个进程容器运行在自己的网络命名空间里，拥有自己的虚拟接口和 IP 地址。</li>
<li>写时复制： 采用写时复制方式创建根文件系统，这让部署变得极其快捷，并且节省内存和硬盘空间。</li>
<li>日志记录： Docker 将会收集和记录每个进程容器的标准流（stdout/stderr/stdin），用于实时检索或批量检索。</li>
<li>变更管理： 容器文件系统的变更可以提交到新的映像中，并可重复使用以创建更多的容器。无需使用模板或手动配置。</li>
<li>交互式 Shell： Docker 可以分配一个虚拟终端并关联到任何容器的标准输入上，例如运行一个一次性交互 shell。</li>
</ul>
<h2 id="Docker-vs-传统虚拟化技术"><a href="#Docker-vs-传统虚拟化技术" class="headerlink" title="Docker vs 传统虚拟化技术"></a>Docker vs 传统虚拟化技术</h2><p>作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式（xen、kvm、vmware）相比具有众多的优势。</p>
<p>首先，Docker 容器的启动可以在秒级实现，这相比传统的虚拟机方式要快得多。 其次，Docker 对系统资源的利用率很高，一台主机上可以同时运行数千个 Docker 容器。容器除了运行其中应用外，基本不消耗额外的系统资源，使得应用的性能很高，同时系统的开销尽量小。传统虚拟机方式运行 10 个不同的应用就要起 10 个虚拟机，而 Docker 只需要启动 10 个隔离的应用即可。</p>
<p>具体说来，Docker 在如下几个方面具有较大的优势。</p>
<ul>
<li><p>更快速的交付和部署<br>对开发和运维（devop）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。<br>开发者可以使用一个标准的镜像来构建一套开发容器，开发完成之后，运维人员可以直接使用这个容器来部署代码。 Docker 可以快速创建容器，快速迭代应用程序，并让整个过程全程可见，使团队中的其他成员更容易理解应用程序是如何创建和工作的。 Docker 容器很轻很快！容器的启动时间是秒级的，大量地节约开发、测试、部署的时间。</p>
</li>
<li><p>更高效的虚拟化<br>Docker 容器的运行不需要额外的 hypervisor 支持，它是内核级的虚拟化，因此可以实现更高的性能和效率。</p>
</li>
<li><p>更轻松的迁移和扩展<br>Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等。 这种兼容性可以让用户把一个应用程序从一个平台直接迁移到另外一个。</p>
</li>
<li><p>更简单的管理<br>使用 Docker，只需要小小的修改，就可以替代以往大量的更新工作。所有的修改都以增量的方式被分发和更新，从而实现自动化并且高效的管理。</p>
</li>
</ul>
<p>对比传统虚拟机总结：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>一般为 MB</td>
<td>一般为 GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千个容器</td>
<td>一般几十个</td>
</tr>
</tbody>
</table>
<h2 id="Docker-vs-lxc"><a href="#Docker-vs-lxc" class="headerlink" title="Docker vs lxc"></a>Docker vs lxc</h2><p>Docker 以 Linux 容器 LXC 为基础，实现轻量级的操作系统虚拟化解决方案。在 LXC 的基础上 Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便，具体改进有</p>
<ul>
<li>Portable deployment across machines</li>
</ul>
<p>Docker 提供了一种可移植的配置标准化机制，允许你一致性地在不同的机器上运行同一个 Container；而 LXC 本身可能因为不同机器的不同配置而无法方便地移植运行；</p>
<ul>
<li>Application-centric</li>
</ul>
<p>Docker 以 App 为中心，为应用的部署做了很多优化，而 LXC 的帮助脚本主要是聚焦于如何机器启动地更快和耗更少的内存；</p>
<ul>
<li><p>Automatic build<br>Docker 为 App 提供了一种自动化构建机制（Dockerfile），包括打包，基础设施依赖管理和安装等等；</p>
</li>
<li><p>Versioning</p>
</li>
</ul>
<p>Docker 提供了一种类似 git 的 Container 版本化的机制，允许你对你创建过的容器进行版本管理，依靠这种机制，你还可以下载别人创建的 Container，甚至像 git 那样进行合并；</p>
<ul>
<li>Component reuse</li>
</ul>
<p>Docker Container 是可重用的，依赖于版本化机制，你很容易重用别人的 Container，作为基础版本进行扩展；</p>
<ul>
<li>Sharing</li>
</ul>
<p>Docker Container 是可共享的，有点类似 github 一样，Docker 有自己的 INDEX，你可以创建自己的 Docker 用户并上传和下载 Docker Image；</p>
<ul>
<li>Tool ecosystem</li>
</ul>
<p>Docker 提供了很多的工具链，形成了一个生态系统；这些工具的目标是自动化、个性化和集成化，包括对 PAAS 平台的支持等。</p>
<h2 id="docker-应用场景"><a href="#docker-应用场景" class="headerlink" title="docker 应用场景"></a>docker 应用场景</h2><p>Docker 作为一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。Docker 可以自动化打包和部署任何应用、创建一个轻量级私有 PaaS 云、搭建开发测试环境、部署可扩展的 Web 应用等。这决定了它在企业中的应用场景是有限的，Docker 将自己定位为“分发应用的开放平台”，其网站上也明确地提到了 Docker的典型应用场景</p>
<blockquote>
<ul>
<li>Automating the packaging and deployment of applications</li>
<li>Creation of lightweight, private PAAS environments</li>
<li>Automated testing and continuous integration/deployment</li>
<li>Deploying and scaling web apps, databases and backend services</li>
</ul>
</blockquote>
<p>对应用进行自动打包和部署，创建轻量、私有的 PAAS 环境，自动化测试和持续整合与部署，部署和扩展Web应用、数据库和后端服务。</p>
<p>平台即服务一般与大数据量系统同在，反观当前我司各 IT 系统，可以在以下情形下使用 docker 替代方案：</p>
<ol>
<li><p>结合 vagrant 或 supervisor，搭建统一的开发、测试环境<br>多个开发人员共同进行一个项目，就必须保持开发环境完全一致，部署到测试环境、正式环境后，最好都是同一套环境，通过容器来保存状态，分发给开发人员或部署，可以让“代码在我机子上运行没有问题”这种说辞将成为历史。</p>
</li>
<li><p>对 memcached、mysql 甚至 tomcat，打包成一个个容器，避免重复配置<br>比如将一个稳定版本的、已配置完善的 mysql，固化在一个镜像中，假如有新的环境要用到 mysql 数据库，便不需要重新安装、配置，而只需要启动一个容器瞬间完成。tomcat 应用场景更多，可以将不同版本的 jvm 和 tomcat 打包分发，应用于多 tomcat 集群，或在测试服务器上隔离多个不同运行环境要求的测试应用（例如旧系统采用的是 jdk6，新系统在jdk7上开发，但共用同一套测试环境）。</p>
</li>
</ol>
<p><strong>docker不足</strong></p>
<ul>
<li><p>LXC 是基于 cgroup 等 linux kernel 功能的，因此 container 的 guest 系统只能是 linux base 的</p>
</li>
<li><p>隔离性相比 KVM之类的虚拟化方案还是有些欠缺，所有 container公用一部分的运行库</p>
</li>
<li><p>网络管理相对简单，主要是基于 namespace 隔离</p>
</li>
<li><p>cgroup 的 cpu 和 cpuset 提供的 cpu 功能相比 KVM 的等虚拟化方案相比难以度量(所以 dotcloud 主要是安内存收费)</p>
</li>
<li><p>container 随着用户进程的停止而销毁，container 中的 log 等用户数据不便收集</p>
</li>
</ul>
<p>另外，Docker 是面向应用的，其终极目标是构建 PAAS 平台，而现有虚拟机主要目的是提供一个灵活的计算资源池，是面向架构的，其终极目标是构建一个 IAAS 平台，所以它不能替代传统虚拟化解决方案。目前在容器可管理性方面，对于方便运维，提供 UI 来管理监控各个 containers的功能还不足，还都是第三方实现如 DockerUI、Dockland、Shipyard 等。</p>
<h2 id="docker-组成部分"><a href="#docker-组成部分" class="headerlink" title="docker 组成部分"></a>docker 组成部分</h2><p><img src="http://czero000.github.io/images/docker/make_docker.png" alt="make_docker"><br>Docker 使用客户端-服务器 (client-server) 架构模式。Docker 客户端会与 Docker 守护进程进行通信。Docker 守护进程会处理复杂繁重的任务，例如建立、运行、发布你的Docker 容器。Docker 客户端和守护进程可以运行在同一个系统上，当然你也可以使用 Docker 客户端去连接一个远程的 Docker 守护进程。Docker 客户端和守护进程之间通过socket或者 RESTful API 进行通信。</p>
<h3 id="images-镜像"><a href="#images-镜像" class="headerlink" title="images 镜像"></a>images 镜像</h3><p>Docker 镜像就是一个只读的模板。例如，一个镜像可以包含一个完整的 ubuntu 操作系统环境，里面仅安装了 Apache 或用户需要的其它应用程序。<br>镜像可以用来创建 Docker 容器。<br>Docker 提供了一个很简单的机制来创建镜像或者更新现有的镜像，用户甚至可以直接从其他人那里下载一个已经做好的镜像来直接使用。</p>
<h3 id="container-容器"><a href="#container-容器" class="headerlink" title="container 容器"></a>container 容器</h3><p>Docker 利用容器来运行应用。容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 镜像是只读的，容器在启动的时候创建一层可写层作为最上层。</p>
<h3 id="repository-仓库"><a href="#repository-仓库" class="headerlink" title="repository 仓库"></a>repository 仓库</h3><p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器（Registry）混为一谈，并不严格区分。实际上，仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p>
<ul>
<li>公开仓库</li>
</ul>
<p>docker团队控制的top-level的顶级repository，即<a href="https://registry.hub.docker.com/" target="_blank" rel="external">Docker Hub</a>，存放了数量庞大的镜像供用户下载，任何人都能读取，里面包含了许多常用的镜像，如ubuntu, mysql ,redis, python等。</p>
<ul>
<li>个人仓库</li>
</ul>
<p>个人公共库也是被托管在Docker Hub上，网络上的其它用户也可以pull你的仓库（如docker pull seanloook/centos6）你可以在修改完自己的container之后，通过commit命令把它变成本地的一个image，push到自己的个人公共库。（在此之前你需要docker login登录，或者vi ~/.dockercfg。）</p>
<ul>
<li>私有仓库</li>
</ul>
<p>首先与另外一种仓库区分——Docker Hub Private Repository，它简单理解为公网上的个人私有库，与上面的个人公共库相对应，在Docker Hub上Create Repository时选择Private便是，只有你自己才可以读写。<br>这里所说的私有仓库是指自己在本地服务器上搭建的专属自己的内部仓库docker-registry，俗称“私服”，供无法访问互联网的内部网络使用，或者镜像到本地一份以加快pull、push的速度。<br>它与公共仓库最明显的区分就是repository的命名，如必须使用带.的主机名或域名，后面必须接:port，如sean.tp-link.net:5000/centos6:your_tag_name，而公共仓库第一个斜杠前表示的是登录用户名。命名关系到推送到哪个服务器的哪个位置，</p>
<h2 id="运行一个容器的内部过程"><a href="#运行一个容器的内部过程" class="headerlink" title="运行一个容器的内部过程"></a>运行一个容器的内部过程</h2><p>docker client告诉docker daemon运行一个容器，例如：docker run -i -t ubuntu /bin/bash<br>让我们分解一下这个命令，docker client启动使用一个二进制的docker命令，最小的docker client需要你告诉docker daemon你的容器是从哪个docker镜像构建的，你希望在容器内部运行哪个命令。所以启动过程如下：</p>
<ul>
<li>Pulling the ubuntu image</li>
</ul>
<p>docker检查是否存在ubuntu镜像，如果本地不存在ubuntu镜像，则docker会到docker index下载。</p>
<ul>
<li>Creates a new container</li>
</ul>
<p>利用镜像创建容器</p>
<ul>
<li>Allocates a filesystem and mounts a read-write layer</li>
</ul>
<p>为镜像创建文件系统层和read-write层</p>
<ul>
<li>Allocates a network / bridge interface</li>
</ul>
<p>为容器创建网络接口，使容器和本地机器可以通讯</p>
<ul>
<li>Sets up an IP address</li>
</ul>
<p>在地址池中为容器分配一个可用的IP地址</p>
<ul>
<li>Executes a process that you specify</li>
</ul>
<p>运行你的应用</p>
<ul>
<li>Captures and provides application output</li>
</ul>
<p>连接log的标准输入、输出、错误，以使你直到你的应用是否正常运行</p>
<h1 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h1><p>Docker可以运行在Ubuntu16.04 LTS 和 CentOS7.x上，可能会和其他的二进制 EL7 兼容工作，但是 Docker 官方并没有去做测试。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>先决条件：</p>
<ul>
<li>运行64为CPU架构（x86_64和amd64），不支持32位</li>
<li>运行Linux3.8 或更高版本，老版本的2.6.x及之后版本也可以运行，但是运行结果大不相同</li>
<li>内核必须支持合适的存储驱动（storagedriver）<ul>
<li>Device Manager</li>
<li>AUFS</li>
<li>vfs</li>
<li>btrfs</li>
</ul>
</li>
<li>内核必须支持并开启cgroup和命名空间功能</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li>更新系统</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">apt-get update</div><div class="line">apt install linux-image-extra-$(uname -r) linux-image-extra-virtual</div><div class="line">apt-get install apt-transport-https ca-certificates</div></pre></td></tr></table></figure>
<ul>
<li>添加 GPG Key</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-key adv --keyserver hkp://p80.pool.sks-keyservers.net:80 --recv-keys 58118E89F3A912897C070ADBF76221572C52609D</div></pre></td></tr></table></figure>
<ul>
<li>增加安装源</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">vim /etc/apt/sources.list.d/docker.list</div><div class="line">// On Ubuntu Precise 12.04 (LTS)</div><div class="line">deb https://apt.dockerproject.org/repo ubuntu-precise main</div><div class="line">// On Ubuntu Trusty 14.04 (LTS)</div><div class="line">deb https://apt.dockerproject.org/repo ubuntu-trusty main</div><div class="line">// Ubuntu Wily 15.10</div><div class="line">deb https://apt.dockerproject.org/repo ubuntu-wily main</div><div class="line">// Ubuntu Xenial 16.04 (LTS)</div><div class="line">deb https://apt.dockerproject.org/repo ubuntu-xenial main</div></pre></td></tr></table></figure>
<ul>
<li>安装docker</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt update</div><div class="line">apt install docker</div></pre></td></tr></table></figure>
<ul>
<li>启动docker</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl start docker</div></pre></td></tr></table></figure>
<ul>
<li>验证启动</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">docker info</div><div class="line">Containers: 0</div><div class="line"> Running: 0</div><div class="line"> Paused: 0</div><div class="line"> Stopped: 0</div><div class="line">Images: 0</div><div class="line">Server Version: 1.12.2</div><div class="line">Storage Driver: aufs</div><div class="line"> Root Dir: /var/lib/docker/aufs</div><div class="line"> Backing Filesystem: extfs</div><div class="line"> Dirs: 0</div><div class="line"> Dirperm1 Supported: true</div><div class="line">Logging Driver: json-file</div><div class="line">Cgroup Driver: cgroupfs</div></pre></td></tr></table></figure>
<h1 id="使用-Docker及-docker-命令汇总"><a href="#使用-Docker及-docker-命令汇总" class="headerlink" title="使用 Docker及 docker 命令汇总"></a>使用 Docker及 docker 命令汇总</h1><h2 id="查看-docker-信息"><a href="#查看-docker-信息" class="headerlink" title="查看 docker 信息"></a>查看 docker 信息</h2><ul>
<li>查看 docker 版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker Version</div></pre></td></tr></table></figure>
<ul>
<li>显示 docker 系统的信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker info</div></pre></td></tr></table></figure>
<h2 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h2><ul>
<li>检索 image</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// docker search image_name</div><div class="line">docker search ubuntu:16.04</div></pre></td></tr></table></figure>
<ul>
<li>下载一个预建立的镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// docker pull image_name</div><div class="line">docker pull ubuntu:16.04</div><div class="line">Digest: sha256:28d4c5234db8d5a634d5e621c363d900f8f241240ee0a6a978784c978fe9c737</div><div class="line">Status: Downloaded newer image for ubuntu:16.04</div></pre></td></tr></table></figure>
<p>这个将从索引仓库中通过名字找到ubuntu镜像，并从索引仓库中心下载到本地镜像存储<br>当镜像下载成功后，你可以看到12位的hash值，如c73a085dc378，这是下载完整的镜像的精简ID，这些短的镜像ID是完整镜像ID前12个字符—可以使用docker inspect或者docker images -no-trunc=true来获取完整镜像ID</p>
<ul>
<li>列出镜像列表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker images</div></pre></td></tr></table></figure>
<ul>
<li>删除一个或者多个镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//docker rmi image_name</div><div class="line">docker rmi ubuntu:16.04</div></pre></td></tr></table></figure>
<ul>
<li>显示一个镜像的历史</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// docker history image_name</div><div class="line">docker history ubuntu:16.04</div></pre></td></tr></table></figure>
<h2 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h2><ul>
<li>创建容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//使用 docker run 命令创建容器,-i 保证容器中 STDIN 开启，-t 分配一个伪终端</div><div class="line">docker run -i -t ubuntu /bin/bash</div></pre></td></tr></table></figure>
<p>使用 ubuntu:16.04 运行一个交互性的 shell,分配一个伪终端，附带 stdin 和 stout ,如果想要退出伪终端，使用 CTRL -p + CTRL -q,容器只有在指定的 /bin/bash 命令处于运行状态，容器才会运行，一旦退出 <code>/bin/bash</code>，容器随之停止。</p>
<p>如果容器因为某种错误导致停止，可以通过<code>--restart</code>标志，让docker自动重启容器。–restart会检查容器的退出状态，并据此来判断是否要重启容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --restart=always --name=docker_test -i -t -d ubuntu:16,04 /bin/bash</div></pre></td></tr></table></figure></p>
<ul>
<li>容器命名</li>
</ul>
<p>容器命名可以是使用小写字母a-z、大写字母A-Z、数字0-9、下划线、圆点、横线。容器的命名必须是唯一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name docker_test -i -t ubuntu:16.04 /bin/bash</div></pre></td></tr></table></figure></p>
<p>可以通过增加 <code>-d</code> 参数，创建一个长时间运行的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --name docker_test -i -t -d ubuntu:16.04 /bin/bash</div></pre></td></tr></table></figure></p>
<ul>
<li>查看容器状态</li>
</ul>
<p>通过 <code>docker ps -a</code>可以列出所有停止、运行的容器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">docker ps -a</div><div class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</div><div class="line">fd74d17e54f1        ubuntu:16.04        &quot;/bin/bash&quot;         2 minutes ago       Up 2 minutes                            docker_test</div></pre></td></tr></table></figure></p>
<ul>
<li>查看容器进程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker top docker_test</div></pre></td></tr></table></figure>
<ul>
<li>深入容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 获取更加详细的 docker 信息</div><div class="line">docker inspect docker_test</div></pre></td></tr></table></figure>
<ul>
<li>启动、重启、连接容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//启动</div><div class="line">docker start docker_test</div><div class="line"></div><div class="line">//停止</div><div class="line">docker stop docker_test</div><div class="line"></div><div class="line">// 杀死</div><div class="line">docker stop docker_test</div><div class="line"></div><div class="line">// 连接</div><div class="line">docker sttach docker_test</div></pre></td></tr></table></figure>
<ul>
<li>在容器内部运行进程</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// -d 表明在后台运行一个进程</div><div class="line">docker exec -d docker_test touch /etc/new_config_file</div><div class="line"></div><div class="line">// 打开一个交互性的shell</div><div class="line">docker exec -i -t docker_test /bin/bash</div></pre></td></tr></table></figure>
<ul>
<li>查看容器输出</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//到目前为止收集的输出</div><div class="line">docker logs docker_test</div><div class="line">//使用-f 可以监控docker输出</div><div class="line">docker logs -f docker_test</div><div class="line">//加上tail 命令可以查看某段输出，如最后10行</div><div class="line">docker log --tail 10 docker_tet</div><div class="line">//使用 -t 可以在每条日志加上时间戳</div><div class="line">docker log -ft docker_test</div></pre></td></tr></table></figure>
<ul>
<li>保存容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// docker commit id new_image_name</div><div class="line">docker commit 2194cf55f5ea docker_test</div></pre></td></tr></table></figure>
<ul>
<li>删除容器</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 所有容器</div><div class="line">docker rm `docker ps -a -q`</div><div class="line">// 指定容器</div><div class="line">docker rm name/id</div></pre></td></tr></table></figure>
<ul>
<li>查看容器被修改的文件或目录</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker diff docker_test</div></pre></td></tr></table></figure>
<ul>
<li>拷贝文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker cp [name|id]:container_path  local_path</div></pre></td></tr></table></figure>
<h2 id="保存和加载镜像"><a href="#保存和加载镜像" class="headerlink" title="保存和加载镜像"></a>保存和加载镜像</h2><ul>
<li>保存镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker save image_name -o file_path</div></pre></td></tr></table></figure>
<ul>
<li>加载本地镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker load -i file_path</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Docker-简介&quot;&gt;&lt;a href=&quot;#Docker-简介&quot; class=&quot;headerlink&quot; title=&quot;Docker 简介&quot;&gt;&lt;/a&gt;Docker 简介&lt;/h1&gt;&lt;h2 id=&quot;Docker-是什么&quot;&gt;&lt;a href=&quot;#Docker-是什么&quot; cla
    
    </summary>
    
      <category term="运维技术" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Docker" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/Docker/"/>
    
    
      <category term="docker" scheme="http://czero000.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Ansible-Playbooks</title>
    <link href="http://czero000.github.io/2016/10/19/ansible-playbook.html"/>
    <id>http://czero000.github.io/2016/10/19/ansible-playbook.html</id>
    <published>2016-10-19T06:41:10.000Z</published>
    <updated>2016-10-19T09:16:47.601Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Playbooks"><a href="#Playbooks" class="headerlink" title="Playbooks"></a>Playbooks</h1><p>Playbooks 是 Ansible 的配置、部署、编排语言，相当于控制远程主机的一系列命令的集合，通过 YAML 语言编写。Ansible-Playbook 命令根据自上而写的顺序依次执行。 Playbook 允许传输摸个命令的状态到后面的指令，或者从一台主机的文件中获取内容并赋值变量，然后传给另外一台主机使用，这是 ansible 命令无法实现的。</p>
<h2 id="YAML-语法介绍"><a href="#YAML-语法介绍" class="headerlink" title="YAML 语法介绍"></a>YAML 语法介绍</h2><h3 id="文件开始符"><a href="#文件开始符" class="headerlink" title="文件开始符"></a>文件开始符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">---</div></pre></td></tr></table></figure>
<h3 id="数组列表"><a href="#数组列表" class="headerlink" title="数组列表"></a>数组列表</h3><p>列表中的所有成员都开始于相同缩进级别，并使用 <code>-</code> 来作为开头<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- Apple</div><div class="line">- Orange</div><div class="line">- Mango</div></pre></td></tr></table></figure></p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典是有一个简单的 <code>Key: value</code> 形式组成，注意 <code>:</code> 后面有<strong>空格</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">name: charlie</div><div class="line">job: Developer</div><div class="line">mail: charlie.cui127@gmail.com</div></pre></td></tr></table></figure></p>
<p>在 playbook 中会有更为复杂的用法</p>
<ul>
<li>字典与字典嵌套</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">martin:</div><div class="line">    name: Martin D&apos;vloper</div><div class="line">    job: Developer</div><div class="line">    skill: Elite</div></pre></td></tr></table></figure>
<ul>
<li>字典与数组的嵌套</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-  martin:</div><div class="line">    name: Martin D&apos;vloper</div><div class="line">    job: Developer</div><div class="line">    skills:</div><div class="line">      - python</div><div class="line">      - perl</div><div class="line">      - pascal</div><div class="line">-  tabitha:</div><div class="line">    name: Tabitha Bitumen</div><div class="line">    job: Developer</div><div class="line">    skills:</div><div class="line">      - lisp</div><div class="line">      - fortran</div><div class="line">      - erlang</div></pre></td></tr></table></figure>
<p>注意，如果变量里有 <code>:</code>,则需要加引号<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">foo: &quot;&#123;&#123; variable &#125;&#125;&quot;</div></pre></td></tr></table></figure></p>
<h1 id="Playbook-基本用法"><a href="#Playbook-基本用法" class="headerlink" title="Playbook 基本用法"></a>Playbook 基本用法</h1><p>最基本的 playbook 分为三部分：</p>
<ol>
<li>在什么机器上以什么身份执行<ul>
<li>hosts</li>
<li>users</li>
</ul>
</li>
<li>定义 playbook 执行需要的变量<ul>
<li>variable</li>
</ul>
</li>
<li>执行的任务是都有什么<ul>
<li>tasks</li>
</ul>
</li>
<li>善后的任务是什么<ul>
<li>handlers  </li>
</ul>
</li>
</ol>
<p><strong>执行 Playbook</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 执行playbook</div><div class="line">Ansible-playbook user.yaml</div><div class="line"></div><div class="line">// 查看详细输出</div><div class="line">ansible-playbook user.yaml --list-hosts</div></pre></td></tr></table></figure>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="官方示例"><a href="#官方示例" class="headerlink" title="官方示例"></a>官方示例</h3><p>要学习更多的 playbook 用法，可以通过<a href="https://github.com/ansible/ansible-examples" target="_blank" rel="external">Playbooks 官方示例</a>。</p>
<h3 id="Playbook-分享平台"><a href="#Playbook-分享平台" class="headerlink" title="Playbook 分享平台"></a>Playbook 分享平台</h3><p>Ansible 提供了一个 Playbook 的分享平台，上面的例子是有 Ansible 使用者自己上传的。<br><a href="https://galaxy.ansible.com/" target="_blank" rel="external">Ansible分享平台</a></p>
<h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><ul>
<li>创建用户</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 新增一个用户</div><div class="line">cat user.yaml</div><div class="line">---</div><div class="line">- name: create user           </div><div class="line">  hosts: all                \\ host or group</div><div class="line">  user: root</div><div class="line">  gather_facts: false</div><div class="line">  vars:                     \\ variable</div><div class="line">  - user: &quot;charlie&quot;</div><div class="line">  tasks:                     \\ tasks</div><div class="line">  - name: create user</div><div class="line">    user: name= &quot;&#123;&#123; user &#125;&#125;&quot;</div><div class="line">    notify: create user ok</div><div class="line">  handlers:</div><div class="line">    - name: create user ok</div><div class="line">      debug: msg= &quot;Create User OK&quot;</div></pre></td></tr></table></figure>
<ol>
<li>name 参数对该 playbook 实现功能的一个概述，后面执行过程中会打印 name 变量值</li>
<li>hosts 参数指定了那些主机</li>
<li>user 参数执行了使用什么用户登陆远程主机</li>
<li>gather_facts 参数指定了下面任务执行前，是否先执行 setup 模块获取主机相关信息，这些后面 task 会使用 setup 获取的信息</li>
<li>vars 参数指定了变量， 变量 user，值为 charlie，值得注意的是参数要用引号</li>
<li>task 指定了一个任务，下面的 name 参数同样是对任务的描述，在执行过程中打印出来。user 指定了调用 user模块，name 是user模块中的参数，增加的用户名是上面 user 的值</li>
</ol>
<p>执行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">ansible-playbook user.yaml</div><div class="line">PLAY [create user] *************************************************************</div><div class="line"></div><div class="line">TASK [create user] *************************************************************</div><div class="line">changed: [172.16.11.210]</div><div class="line">changed: [172.16.11.211]</div><div class="line"></div><div class="line">RUNNING HANDLER [create user] **************************************************</div><div class="line">ok: [172.16.11.210] =&gt; &#123;</div><div class="line">    &quot;msg&quot;: &quot;Create User OK&quot;</div><div class="line">&#125;</div><div class="line">ok: [172.16.11.211] =&gt; &#123;</div><div class="line">    &quot;msg&quot;: &quot;Create User OK&quot;</div><div class="line">&#125;</div><div class="line">PLAY RECAP *********************************************************************</div><div class="line">172.16.11.210              : ok=1    changed=1    unreachable=0    failed=0   </div><div class="line">172.16.11.211              : ok=1    changed=1    unreachable=0    failed=0</div></pre></td></tr></table></figure></p>
<ul>
<li>安装apache</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">cat apache.yaml</div><div class="line">---</div><div class="line">- hosts: all</div><div class="line"> vars:</div><div class="line">   http_port: 80</div><div class="line">   max_clients: 2048</div><div class="line"> user: root</div><div class="line"> tasks:</div><div class="line"> - name: ensure apache is at latest version</div><div class="line">   yum: pkg=httpd state=latest</div><div class="line"> - name: write the apache config file</div><div class="line">   template: src=/srv/httpd.j2 dest=/etc/httpd.conf</div><div class="line">   notify:</div><div class="line">   - restart apache</div><div class="line"> - name: ensure apache is running</div><div class="line">   service: name=httpd state=started</div><div class="line"> handlers:</div><div class="line">   - name: restart apache</div><div class="line">     service: name=httpd state=restarted</div></pre></td></tr></table></figure>
<h2 id="主机和用户-Host-and-User"><a href="#主机和用户-Host-and-User" class="headerlink" title="主机和用户 Host and User"></a>主机和用户 Host and User</h2><p>在执行 playbook 时，可以选择操作的目标主机是那些，以那个用户执行<br>host 行的内容是一个或多个主机的 patterns， 以逗号分隔<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: 172.16.11.210, 172.16.11.211, [all]</div><div class="line">  remote_user: root</div></pre></td></tr></table></figure></p>
<p>还可以在每个 task 中，定义远程执行用户<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: all</div><div class="line">  user: root</div><div class="line">  tasks:</div><div class="line">  - name: test connection</div><div class="line">    ping:</div><div class="line">    remote_user: root</div></pre></td></tr></table></figure></p>
<p>也支持 sudo 方法,在 task中同样支持,在 sudo 需要密码时，可以加上选项 –ask-sudo-pass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: all</div><div class="line">  remote_user: charlie</div><div class="line">  sudo: yes</div><div class="line">  task：</div><div class="line">    - service： name=nginx state=started</div><div class="line">      sudo: yes</div><div class="line">      sudo_user: root</div></pre></td></tr></table></figure></p>
<h2 id="任务列表-Tasks"><a href="#任务列表-Tasks" class="headerlink" title="任务列表 Tasks"></a>任务列表 Tasks</h2><ul>
<li>tasks 是从上到下顺序执行，如果中间发生错误，整个 playbook 便会中断。</li>
<li>每一个 task 是对module的一次调用,通常会带有特定参数，参数可以使用变量。</li>
<li>每一个 task 必须有一个 name 属性，name 值会在命令行中输出，以提示用户，如果没有定义，aciton 的值会作为输出信息来标记task</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">tasks:</div><div class="line">  - name: make sure apache is running</div><div class="line">    service: name=httpd state=running</div><div class="line"></div><div class="line">// 如果参数过长，可以使用空格或者缩进分隔为多行</div><div class="line">tasks:</div><div class="line">  - name: copy ansible inventory file to client</div><div class="line">    copy: src=/etc/ansible/hosts dest=/etc/ansible/hosts</div><div class="line">          owner=root group=root mode=0644</div><div class="line"></div><div class="line">// 或者使用 yaml 的字典作为参数</div><div class="line">tasks:</div><div class="line">  - name: copy ansible inventory file to client</div><div class="line">    copy:</div><div class="line">      src: /etc/ansible/hosts</div><div class="line">      dest: /etc/ansible/hosts</div><div class="line">      owner: root</div><div class="line">      group: root</div><div class="line">      mode: 0644</div><div class="line"></div><div class="line">// 大部分的模块都是使用 `key-value` 这种格式的，其中有两个比较特殊，command 和 shell 模块。</div><div class="line">tasks:</div><div class="line">  - name: disable selinux</div><div class="line">    command: /sbin/setenforce 0</div><div class="line">tasks:</div><div class="line">  - name: run this command and ignore the result</div><div class="line">    shell: /usr/bin/command || /bin/true</div><div class="line">tasks:</div><div class="line">  - name: run some command and ignore the reslut</div><div class="line">    shell: /usr/bin/somecommadn</div><div class="line">    ignore_error: True</div></pre></td></tr></table></figure>
<h3 id="执行状态"><a href="#执行状态" class="headerlink" title="执行状态"></a>执行状态</h3><p>task 中每个 action 会调用一个 module，在 module 中会去检查当前系统状态是否需要重新执行，具体判断需要有各个 module 自己来实现。</p>
<ul>
<li>如果执行那么 action 会得到返回值 changed；</li>
<li>如果部执行，那么 action 会得到返回值 OK</li>
</ul>
<p><strong>状态实例 以一个 copy 文件为例</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">// playbook</div><div class="line">copy.yaml                 </div><div class="line">---</div><div class="line">- name: copy a test file</div><div class="line">  hosts: all</div><div class="line">  user: root</div><div class="line">  tasks:</div><div class="line">    - name: copy a test file to /opt/ansible</div><div class="line">      copy: src=/opt/ansible/test.txt dest=/opt/ansible/</div><div class="line"></div><div class="line">// 第一次执行结果</div><div class="line">ansible-playbook copy.yaml</div><div class="line">PLAY [copy a test file] ********************************************************</div><div class="line"></div><div class="line">TASK [setup] *******************************************************************</div><div class="line">ok: [172.16.11.211]</div><div class="line">ok: [172.16.11.210]</div><div class="line"></div><div class="line">TASK [copy a test file to /opt/ansible] ****************************************</div><div class="line">changed: [172.16.11.210]</div><div class="line">changed: [172.16.11.211]</div><div class="line"></div><div class="line">PLAY RECAP *********************************************************************</div><div class="line">172.16.11.210              : ok=2    changed=1    unreachable=0    failed=0   </div><div class="line">172.16.11.211              : ok=2    changed=1    unreachable=0    failed=0   </div><div class="line"></div><div class="line">// 第二次执行结果</div><div class="line">ansible-playbook copy.yaml</div><div class="line"></div><div class="line">PLAY [copy a test file] ********************************************************</div><div class="line"></div><div class="line">TASK [setup] *******************************************************************</div><div class="line">ok: [172.16.11.211]</div><div class="line">ok: [172.16.11.210]</div><div class="line"></div><div class="line">TASK [copy a test file to /opt/ansible] ****************************************</div><div class="line">ok: [172.16.11.210]</div><div class="line">ok: [172.16.11.211]</div><div class="line"></div><div class="line">PLAY RECAP *********************************************************************</div><div class="line">172.16.11.210              : ok=2    changed=0    unreachable=0    failed=0   </div><div class="line">172.16.11.211              : ok=2    changed=0    unreachable=0    failed=0</div></pre></td></tr></table></figure></p>
<p>可以看到第一次 task的状态是 changed 状态，第二次再次执行，task 状态是 OK，说明文件已经存在，避免 ansible 再次重复执行。</p>
<h2 id="响应事件-Handler"><a href="#响应事件-Handler" class="headerlink" title="响应事件 Handler"></a>响应事件 Handler</h2><h3 id="什么是-handler"><a href="#什么是-handler" class="headerlink" title="什么是 handler"></a>什么是 handler</h3><p>每个主流的变成语言都会有 event 机制，那么 handler 就是 playbook 的 event。Handler 里面的每个 handler，也是对 module 的一次调用。不同的是 handler 不会默认的按照顺序执行。<br>Tasks 中的任务是有状态的，changed 或者 ok。 在 Ansible 中，只有 task 的执行状态为 changed 时，才会触发，这就是 handler。</p>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>如果在 tasks 中修改了某个服务的配置文件，就需要重新启动服务，重新启动服务就可以设计成为一个 handler</p>
<h3 id="触发Handlers"><a href="#触发Handlers" class="headerlink" title="触发Handlers"></a>触发Handlers</h3><p><strong>只有 action 是 changed 时，才会执行 handler</strong></p>
<ul>
<li>第一次执行时，tasks 的状态是 changed， 回触发 handler</li>
<li>第二次执行时，task 的状态是 OK， 那么就不会触发 handler</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">// 一个 handler 最多被执行一次,在任务执行中，有多个 task notify 同一个 handler， 那么只执行一次</div><div class="line">---</div><div class="line">- name: handler state</div><div class="line">  hosts: all</div><div class="line">  remote_user: root</div><div class="line">  vars:</div><div class="line">    random_number1: &quot;&#123;&#123; 10 | random &#125;&#125;&quot;</div><div class="line">    random_number2: &quot;&#123;&#123; 100 | random &#125;&#125;&quot;</div><div class="line">  tasks:</div><div class="line">  - name: Copy the /etc/hosts to /opt/ansible/host.&#123;&#123; random_number1 &#125;&#125;</div><div class="line">    copy: src=/etc/hosts dest=/opt/ansible/host.&#123;&#123; random_number1 &#125;&#125;</div><div class="line">    notify:</div><div class="line">      - call in every action</div><div class="line">  - name: Copy the /etc/hosts to /opt/ansible/host.&#123;&#123; random_number2 &#125;&#125;</div><div class="line">    copy: src=/etc/hosts dest=/opt/ansible/host.&#123;&#123; random_number2 &#125;&#125;</div><div class="line">    notify:</div><div class="line">      - call in every action</div><div class="line">  handlers:</div><div class="line">    - name: call in every action</div><div class="line">      debug: msg=&apos;call in every action, but execute only one time&apos;</div><div class="line"></div><div class="line">// 按照 handler 的定义顺序执行,handlers 是按照在 handlers 中定义的顺序执行的， 而不是按照 notify 的顺序执行的</div><div class="line">// notify 的定义顺序是 3 &gt; 2 &gt; 1，而实际 handler 结果是 handler 定义的顺序 1 &gt; 2 &gt; 3。</div><div class="line">cat handler_notify.yaml                 </div><div class="line">---</div><div class="line">- hosts: all</div><div class="line">  gather_facts: no</div><div class="line">  remote_user: root</div><div class="line">  vars:</div><div class="line">    random_number1: &quot;&#123;&#123; 10 | random &#125;&#125;&quot;</div><div class="line">    random_number2: &quot;&#123;&#123; 100 | random &#125;&#125;&quot;</div><div class="line">    random_number3: &quot;&#123;&#123; 1000 | random &#125;&#125;&quot;</div><div class="line">  tasks:</div><div class="line">    - name: copy the /ets/hosts to /tmp/hosts.&#123;&#123; random_number1 &#125;&#125;</div><div class="line">      copy: src=/etc/hosts dest=/tmp/hosts.&#123;&#123; random_number1 &#125;&#125;</div><div class="line">      notify:</div><div class="line">        - define the 3nd handler</div><div class="line"></div><div class="line">    - name: copy the /ets/hosts to /tmp/hosts.&#123;&#123; random_number2 &#125;&#125;</div><div class="line">      copy: src=/etc/hosts dest=/tmp/hosts.&#123;&#123; random_number2 &#125;&#125;</div><div class="line">      notify:</div><div class="line">        - define the 2nd handler</div><div class="line"></div><div class="line">    - name: copy the /ets/hosts to /tmp/hosts.&#123;&#123; random_number3 &#125;&#125;</div><div class="line">      copy: src=/etc/hosts dest=/tmp/hosts.&#123;&#123; random_number3 &#125;&#125;</div><div class="line">      notify:</div><div class="line">        - define the 1nd handler</div><div class="line">  handlers:</div><div class="line">    - name: define the 1nd handler</div><div class="line">      debug: msg=&quot; defind the 1nd handler&quot;</div><div class="line"></div><div class="line">    - name: define the 2nd handler</div><div class="line">      debug: msg=&quot; defind the 2nd handler&quot;</div><div class="line"></div><div class="line">    - name: define the 3nd handler</div><div class="line">      debug: msg=&quot; defind the 3nd handler&quot;</div></pre></td></tr></table></figure>
<h1 id="playbook-roles-和-include"><a href="#playbook-roles-和-include" class="headerlink" title="playbook roles 和 include"></a>playbook roles 和 include</h1><p>在刚开始使用 playbook 时，习惯性会把 playbook 写成一个很大的文件，然而在实际情况下， 有些文件是可以重用的。playbook 可以使用 include，把其他 playbook 文件中的 variables、tasks 或者 handlers 从其他文件拉取过来。</p>
<h2 id="规划目录组织结构"><a href="#规划目录组织结构" class="headerlink" title="规划目录组织结构"></a>规划目录组织结构</h2><p>通过目录规格，可以使 playbook 模块化，使代码易读、可以重用、层次清晰。</p>
<p>可以通过 <code>ansible-galaxy</code> 工具，初始化一个 role 目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">// init</div><div class="line">ansible-galaxy init httpd</div><div class="line"></div><div class="line">// tree</div><div class="line">.</div><div class="line">├── defaults</div><div class="line">│   └── main.yml</div><div class="line">├── files</div><div class="line">├── handlers</div><div class="line">│   └── main.yml</div><div class="line">├── meta</div><div class="line">│   └── main.yml</div><div class="line">├── README.md</div><div class="line">├── tasks</div><div class="line">│   └── main.yml</div><div class="line">├── templates</div><div class="line">├── tests</div><div class="line">│   ├── inventory</div><div class="line">│   └── test.yml</div><div class="line">└── vars</div><div class="line">    └── main.yml</div></pre></td></tr></table></figure></p>
<h2 id="include-语句"><a href="#include-语句" class="headerlink" title="include 语句"></a>include 语句</h2><h3 id="普通用法"><a href="#普通用法" class="headerlink" title="普通用法"></a>普通用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 可以像其他 include 语句一样， 直接include</div><div class="line"># possibly saved as tasks/firewall_httpd_default.yaml</div><div class="line">- name: insert firewalld rule for httpd</div><div class="line">  firewalld: port=80/tcp permanent=true state=enable immediate=yes</div><div class="line"></div><div class="line">// main.yml</div><div class="line">tasks:</div><div class="line">  - include: tasks/firewall_httpd_default.yml</div></pre></td></tr></table></figure>
<h3 id="高级用法，传递参数"><a href="#高级用法，传递参数" class="headerlink" title="高级用法，传递参数"></a>高级用法，传递参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 添加参数</div><div class="line">tasks:</div><div class="line">  - include: tasks/firewall.yml port=80</div><div class="line">  - include: tasks/firewall.yml port=3306</div><div class="line"></div><div class="line">//  支持结构化</div><div class="line">tasks:</div><div class="line">  - include: tasks/firewall.yml</div><div class="line">    vars:</div><div class="line">      wp_user: charlie</div><div class="line">      ssh_key:</div><div class="line">        - key/one.txt</div><div class="line">        - key/two.txt</div><div class="line">// json格式</div><div class="line">tasks:</div><div class="line">  - &#123; include: wordpress.yml, wp_user: timmy, ssh_keys: [ &apos;key/one.txt&apos;, &apos;key/two.txt&apos; ] &#125;</div></pre></td></tr></table></figure>
<h3 id="在-handlers-section-中定义"><a href="#在-handlers-section-中定义" class="headerlink" title="在 handlers section 中定义"></a>在 handlers section 中定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// handlers.yml</div><div class="line">// this might be in a file line handlers/handlers.yml</div><div class="line">- name: restart apache</div><div class="line">  service: name = apache state=restarted</div><div class="line">// 在一个 playbook 中引用 handlers.yml</div><div class="line">handlers:</div><div class="line">  - include: handlers/handlers.yml</div></pre></td></tr></table></figure>
<p>include 语句可以和其他非 include 的 tasks 和 handlers 混合使用。</p>
<p><strong>例如：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">- name: this is a play at the top level of a file</div><div class="line">  host: all</div><div class="line">  remote_user: root</div><div class="line">  tasks:</div><div class="line">    - name: say hi</div><div class="line">      tags: foo</div><div class="line">      shell: echo &quot;Hi &quot;</div><div class="line">- include: load_balancers.yml</div><div class="line">- include: webservers.yml</div><div class="line">- include: dbservers.yml</div></pre></td></tr></table></figure></p>
<h2 id="Roles"><a href="#Roles" class="headerlink" title="Roles"></a>Roles</h2><p>Ansible 中还有一个比 include 更为强大的代码重用机制，那就是roles！。Roles 基于一个已知的文件结构，去自动加载某些 var_files, tasks, handlers，基于 roles 对内容进行分组，更有利于与其他用户分享 roles。<br>Ansible提供了一个分享role的平台, <a href="https://galaxy.ansible.com/" target="_blank" rel="external">https://galaxy.ansible.com/</a>, 在galaxy上可以找到别人写好的role.</p>
<h3 id="Roled的目录结构"><a href="#Roled的目录结构" class="headerlink" title="Roled的目录结构"></a>Roled的目录结构</h3><p>在 ansible 中，通过遵循特定的目录结构，可以实现对 role 的定义。下面的目录结构是定义了两个 role， 一个名字是 common，另外一个是 webserver，并在 site.yml 中调用这两个 role。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// role 的目录结构</div><div class="line">site.yml</div><div class="line">webservers.yml</div><div class="line">fooservers.yml</div><div class="line">roles/</div><div class="line">   common/</div><div class="line">     files/</div><div class="line">     templates/</div><div class="line">     tasks/</div><div class="line">     handlers/</div><div class="line">     vars/</div><div class="line">     defaults/</div><div class="line">     meta/</div><div class="line">   webservers/</div><div class="line">     files/</div><div class="line">     templates/</div><div class="line">     tasks/</div><div class="line">     handlers/</div><div class="line">     vars/</div><div class="line">     defaults/</div><div class="line">     meta/</div><div class="line"></div><div class="line">// site.yml 中使用</div><div class="line">---</div><div class="line">- hosts: webservers</div><div class="line">  roles:</div><div class="line">    - common</div><div class="line">    - webservers</div></pre></td></tr></table></figure></p>
<h3 id="使用带参数的-role"><a href="#使用带参数的-role" class="headerlink" title="使用带参数的 role"></a>使用带参数的 role</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: webservers</div><div class="line">  roles:</div><div class="line">    - common</div><div class="line">    - &#123; role: foo_app_instance, dir: &apos;/opt/a&apos;, port: 5000 &#125;</div><div class="line">    - &#123; role: foo_app_instance, dir: &apos;/opt/b&apos;, port: 5001 &#125;</div><div class="line">// 设置触发条件,条件语句应用到 role 中的每个 task上。</div><div class="line">---</div><div class="line">- hosts: webservers</div><div class="line">  roles:</div><div class="line">    - &#123; role: some_role, when: &quot;ansible_os_family == &apos;RedHat&apos;&quot; &#125;</div><div class="line">// 分配 tags</div><div class="line">---</div><div class="line">- hosts: webservers</div><div class="line">  roles:</div><div class="line">    - &#123; role: foo, tags: [ &quot;bar&quot; , &quot;baz&quot; ] &#125;</div></pre></td></tr></table></figure>
<h3 id="指定默认的参数"><a href="#指定默认的参数" class="headerlink" title="指定默认的参数"></a>指定默认的参数</h3><p>在指定默认参数后，如果在调用时传参数，那么就使用传入的参数值，否则使用默认参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//指定默认参数</div><div class="line">main.yml</div><div class="line">roles:</div><div class="line">  role_with_var</div><div class="line">    tasks:</div><div class="line">      main.yml</div><div class="line">    vars:</div><div class="line">      main.yml</div><div class="line">// roles/role_with_var/vars/main.yml</div><div class="line">param: &quot;I am the default value&quot;</div></pre></td></tr></table></figure></p>
<h3 id="与条件语句一起执行"><a href="#与条件语句一起执行" class="headerlink" title="与条件语句一起执行"></a>与条件语句一起执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//定义只有在 RedHat 系列才执行的 role</div><div class="line">---</div><div class="line">- host: webservers</div><div class="line">  roles:</div><div class="line">    - &#123; role: some_role, when: &quot;ansible_os_family == &apos;RedHat&apos;&quot; &#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Playbooks&quot;&gt;&lt;a href=&quot;#Playbooks&quot; class=&quot;headerlink&quot; title=&quot;Playbooks&quot;&gt;&lt;/a&gt;Playbooks&lt;/h1&gt;&lt;p&gt;Playbooks 是 Ansible 的配置、部署、编排语言，相当于控制远程主机的
    
    </summary>
    
      <category term="运维自动化" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="Ansible" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/Ansible/"/>
    
    
      <category term="ansible" scheme="http://czero000.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Ansible--变量使用</title>
    <link href="http://czero000.github.io/2016/10/19/ansible-variable.html"/>
    <id>http://czero000.github.io/2016/10/19/ansible-variable.html</id>
    <published>2016-10-19T06:38:32.000Z</published>
    <updated>2016-10-19T09:17:15.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>自动化技术使得重复做事变的更加容易，当系统有所不同，Ansible 可以是使用相同的 template，通过变量来处理不同系统。<br>Ansible 的变量名称可以以 <strong><code>字母、数字和下划线</code></strong> 命名，变量开头要以 <strong>字母开头</strong></p>
<ul>
<li>在 inventory 中定义变量</li>
</ul>
<p>可以参考 「Ansible–入门」 inventory 章节介绍</p>
<ul>
<li>在 playbook 中定义变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- hosts: web</div><div class="line">  vars:</div><div class="line">    http_port: 80</div></pre></td></tr></table></figure>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>在 template 语言 jinjia2 的语法引用，利用中括号和点号来访问子属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">foo[&apos;field1&apos;]</div><div class="line">foo.field2</div></pre></td></tr></table></figure></p>
<h2 id="在-playbook-中使用变量"><a href="#在-playbook-中使用变量" class="headerlink" title="在 playbook 中使用变量"></a>在 playbook 中使用变量</h2><p>在 playbook 中使用，需要用两个大括号引用即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: webservers</div><div class="line">  vars:</div><div class="line">    apache_config: labs.conf</div><div class="line">  tasks:</div><div class="line">    - name: deploy haproxy config</div><div class="line">      template: src=&#123;&#123; apache_config &#125;&#125; dest=/etc/httpd/conf.d/&#123;&#123; apache_config &#125;&#125;</div></pre></td></tr></table></figure>
<p>在 playbook 中使用变量文件定义变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: webservers</div><div class="line">  vars_files:</div><div class="line">    - vars/server_vars.yml</div><div class="line">  tasks:</div><div class="line">    - name: deploy haproxy config</div><div class="line">      template: src=&#123;&#123; apache_config &#125;&#125; dest=/etc/httpd/conf.d/&#123;&#123; apache_config &#125;&#125;</div></pre></td></tr></table></figure></p>
<p>变量文件 <code>vars/server_vars.yml</code> 内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apache_config: labs.conf</div></pre></td></tr></table></figure></p>
<h3 id="YAML-陷阱"><a href="#YAML-陷阱" class="headerlink" title="YAML 陷阱"></a>YAML 陷阱</h3><p>YAML 语法要求如果值以 <code></code> 开头，需要讲整行用双引号扩起来，为了确保你不是在声明一个字典。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">// 错误</div><div class="line">---</div><div class="line">- hosts: app_servers</div><div class="line">  vars:</div><div class="line">    app_path: &#123;&#123; base_path &#125;&#125;/22</div><div class="line">// 正确</div><div class="line">---</div><div class="line">- hosts: app_servers</div><div class="line">  vars:</div><div class="line">    app_path: &quot;&#123;&#123; base_path &#125;&#125;/22&quot;</div></pre></td></tr></table></figure></p>
<h2 id="使用-Facts-获取主机系统变量"><a href="#使用-Facts-获取主机系统变量" class="headerlink" title="使用 Facts 获取主机系统变量"></a>使用 Facts 获取主机系统变量</h2><p>Ansible 可以通过 module_setup 收集远程主机的系统信息–facts，通过 facts 收集的信息，可以以变量形式来使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ansible all -m setup</div></pre></td></tr></table></figure></p>
<h3 id="在-playbook-中使用-facts-变量"><a href="#在-playbook-中使用-facts-变量" class="headerlink" title="在 playbook 中使用 facts 变量"></a>在 playbook 中使用 facts 变量</h3><p>命令会返回海量的变量数据，这些变量可以在 playbook 中直接使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: all</div><div class="line">  name: install some package</div><div class="line">  user: root</div><div class="line">  tasks:</div><div class="line">    - name: echo system</div><div class="line">      shell: echo &#123;&#123; ansible_os_family &#125;&#125;</div><div class="line">    - name: install Git on RedHat</div><div class="line">      yum: name=git state=present</div><div class="line">      when: ansible_os_family == &quot;RedHat&quot;</div><div class="line">    - name: install Git on Debian</div><div class="line">      apt: name=git state=installed</div><div class="line">      when: ansible_os_family == &quot;Debian&quot;</div></pre></td></tr></table></figure></p>
<h3 id="使用复杂的-facts-变量"><a href="#使用复杂的-facts-变量" class="headerlink" title="使用复杂的 facts 变量"></a>使用复杂的 facts 变量</h3><p>使用通过 fact 收集到复杂的、多层次的变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&quot;ansible_eth1&quot;: &#123;</div><div class="line">            &quot;active&quot;: true,</div><div class="line">            &quot;device&quot;: &quot;eth1&quot;,</div><div class="line">            &quot;ipv4&quot;: &#123;</div><div class="line">                &quot;address&quot;: &quot;172.16.11.210&quot;,</div><div class="line">                &quot;broadcast&quot;: &quot;172.16.11.255&quot;,</div><div class="line">                &quot;netmask&quot;: &quot;255.255.255.0&quot;,</div><div class="line">                &quot;network&quot;: &quot;172.16.11.0&quot;</div><div class="line">            &#125;,</div><div class="line">            &quot;ipv6&quot;: [</div><div class="line">                &#123;</div><div class="line">                    &quot;address&quot;: &quot;fe80::5054:ff:fec0:b2b3&quot;,</div><div class="line">                    &quot;prefix&quot;: &quot;64&quot;,</div><div class="line">                    &quot;scope&quot;: &quot;link&quot;</div><div class="line">                &#125;</div><div class="line">            ],</div><div class="line">            &quot;macaddress&quot;: &quot;52:54:00:c0:b2:b3&quot;,</div><div class="line">            &quot;module&quot;: &quot;virtio_net&quot;,</div><div class="line">            &quot;mtu&quot;: 1500,</div><div class="line">            &quot;pciid&quot;: &quot;virtio1&quot;,</div><div class="line">            &quot;promisc&quot;: false,</div><div class="line">            &quot;type&quot;: &quot;ether&quot;</div><div class="line">        &#125;,</div></pre></td></tr></table></figure></p>
<p>可以通过下面两种方式访问到复杂变量的自变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 中括号</div><div class="line">&#123;&#123; ansible_eth1[&quot;ipv4&quot;][&quot;address&quot;] &#125;&#125;</div><div class="line">// 点号</div><div class="line">&#123;&#123; ansible_eth1.ipv4.address &#125;&#125;</div></pre></td></tr></table></figure>
<h3 id="关闭facts"><a href="#关闭facts" class="headerlink" title="关闭facts"></a>关闭facts</h3><p>在 playbook 中， 可以设置是否启用 gather_facts 来获取远程系统信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: webservers</div><div class="line">  gather_facts: no</div></pre></td></tr></table></figure></p>
<h3 id="使用被控端自定义变量"><a href="#使用被控端自定义变量" class="headerlink" title="使用被控端自定义变量"></a>使用被控端自定义变量</h3><p>在被控端可以在 <code>/etc/ansible/facts.d</code> 目录中，任何以 <code>.fact</code> 结尾的文件都可以在 Ansible 提供局部 facts。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//定义 /etc/ansible/facts.d/perferences.fact 文件</div><div class="line">[general]</div><div class="line">abcd=1</div><div class="line">bcde=2</div><div class="line"></div><div class="line">// 主控端获取变量</div><div class="line">172.16.11.210 | SUCCESS =&gt; &#123;</div><div class="line">    &quot;ansible_facts&quot;: &#123;</div><div class="line">        &quot;ansible_local&quot;: &#123;</div><div class="line">            &quot;perferences&quot;: &#123;</div><div class="line">                &quot;general&quot;: &#123;</div><div class="line">                    &quot;abcd&quot;: &quot;1&quot;,</div><div class="line">                    &quot;bcde&quot;: &quot;2&quot;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    &quot;changed&quot;: false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样就可以在 playbook 中引用变量或者覆盖掉系统的 facts 值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: all</div><div class="line">  user: root</div><div class="line">  tasks:</div><div class="line">    - name: create directory for ansible custom facts</div><div class="line">      file: state=directory recurse=yes path=/etc/ansible/facts.d/</div><div class="line">    - name: install custom ipmi fact</div><div class="line">      copy: src=/opt/ansible/playbooks/ipmi.fact dest=/etc/ansible/facts.d</div><div class="line">    - name: re-read facts after adding custom fact</div><div class="line">      setup: filter=ansible_local</div></pre></td></tr></table></figure></p>
<h2 id="注册变量"><a href="#注册变量" class="headerlink" title="注册变量"></a>注册变量</h2><p>可以把 tasks 运行结果作为变量，供后面的 action 使用，在运行 playbook 时，可以使用 -v 参数看到结果值，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: webservers</div><div class="line">  tasks:</div><div class="line">    - shell: /bin/ls</div><div class="line">      register: result</div><div class="line">      ignore_errors: true</div><div class="line">    - shell: /bin/echo &quot;&#123;&#123; result.stdout &#125;&#125;&quot;</div><div class="line">      when: result.rc == 5</div><div class="line">    - debug: msg=&quot;&#123;&#123; result.stdout &#125;&#125;&quot;</div></pre></td></tr></table></figure></p>
<h2 id="在文件模板中使用变量"><a href="#在文件模板中使用变量" class="headerlink" title="在文件模板中使用变量"></a>在文件模板中使用变量</h2><p>Ansible 使用的模本是 python 的一个 jinja2 模板。在 playbook 中定义的变量，可以直接在 template 中使用。</p>
<h3 id="template-变量的定义"><a href="#template-变量的定义" class="headerlink" title="template 变量的定义"></a>template 变量的定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 使用template module来拷贝文件 index.html.j2，并替换 index.html.j2 中的变量为 playbook 中定义的变量。</div><div class="line">---</div><div class="line">- hosts: web</div><div class="line">  vars:</div><div class="line">    http_port: 80</div><div class="line">    defined_name: &quot;Hello My name is Charlie&quot;</div><div class="line">  remote_user: root</div><div class="line">  tasks:</div><div class="line">  - name: ensure apache is at the latest version</div><div class="line">    yum: pkg=httpd state=latest</div><div class="line"></div><div class="line">  - name: Write the configuration file</div><div class="line">    template: src=templates/httpd.conf.j2 dest=/etc/httpd/conf/httpd.conf</div><div class="line">    notify:</div><div class="line">    - restart apache</div><div class="line"></div><div class="line">  - name: Write the default index.html file</div><div class="line">    template: src=templates/index2.html.j2 dest=/var/www/html/index.html</div><div class="line"></div><div class="line">  - name: ensure apache is running</div><div class="line">    service: name=httpd state=started</div><div class="line">  - name: insert firewalld rule for httpd</div><div class="line">    firewalld: port=&#123;&#123; http_port &#125;&#125;/tcp permanent=true state=enabled immediate=yes</div><div class="line"></div><div class="line">  handlers:</div><div class="line">    - name: restart apache</div><div class="line">      service: name=httpd state=restarted</div></pre></td></tr></table></figure>
<h3 id="template-变量的使用"><a href="#template-变量的使用" class="headerlink" title="template 变量的使用"></a>template 变量的使用</h3><p>在 template index.html.j2 中可以直接使用系统变量和用户自定义的变量</p>
<ul>
<li>系统变量 <strong>, </strong></li>
<li>用户自定义变量： <strong></strong></li>
</ul>
<h2 id="命令行中传递变量"><a href="#命令行中传递变量" class="headerlink" title="命令行中传递变量"></a>命令行中传递变量</h2><p>在执行 playbook 命令时可以通过 <code>vars_prompt</code> 和 <code>vars_files</code> 传递变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: &apos;&#123;&#123; hosts &#125;&#125;&apos;</div><div class="line">  remote_user: &apos;&#123;&#123; user &#125;&#125;&apos;</div><div class="line">  tasks:</div><div class="line">    - ....</div><div class="line">// 在命令行中传递参数</div><div class="line">ansible-playbook release.yml --extra-vars &quot;hosts=webservers user=web&quot;</div><div class="line"></div><div class="line">// 使用 JSON 格式传递参数</div><div class="line">ansible-playbook release.yml --extra-vars &quot;&#123;&apos;hosts&apos;:&apos;webservers&apos;, &apos;user&apos;:&apos;web&apos;&#125;&quot;</div><div class="line"></div><div class="line">// 通过文件传递参数</div><div class="line">ansible-playbook release.yml --extra-vars &quot;@vars.json&quot;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;headerlink&quot; title=&quot;变量&quot;&gt;&lt;/a&gt;变量&lt;/h1&gt;&lt;p&gt;自动化技术使得重复做事变的更加容易，当系统有所不同，Ansible 可以是使用相同的 template，通过变量来处理不同系统。&lt;br&gt;An
    
    </summary>
    
      <category term="运维自动化" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="Ansible" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/Ansible/"/>
    
    
      <category term="ansible" scheme="http://czero000.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Ansible--高级技巧</title>
    <link href="http://czero000.github.io/2016/10/19/the-advanced-ansible.html"/>
    <id>http://czero000.github.io/2016/10/19/the-advanced-ansible.html</id>
    <published>2016-10-19T06:37:23.000Z</published>
    <updated>2016-10-19T09:17:15.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Ansible-性能优化"><a href="#Ansible-性能优化" class="headerlink" title="Ansible 性能优化"></a>Ansible 性能优化</h1><p>在使用 Ansible 过程中，当管理的服务器数量增加，就会有一个无法避免的问题–执行效率慢。下面是一些解决方法</p>
<h2 id="优化前的准备–收集数据"><a href="#优化前的准备–收集数据" class="headerlink" title="优化前的准备–收集数据"></a>优化前的准备–收集数据</h2><p>在做性能优化之前首先要收集一些统计数据，这样才能为后面的性能优化提供数据支持，对比优化前后结果，这里推荐一个 Ansible 任务计时插件 <code>ansible-profile</code>， 安装这个插件之后， 会显示 ansible-playbook 执行每个任务话费的时间。项目地址: <a href="https://github.com/jlafon/ansible-profile" target="_blank" rel="external">https://github.com/jlafon/ansible-profile</a> 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mkdir callback_plugins</div><div class="line">cd callback_plugins</div><div class="line">wget https://raw.githubusercontent.com/jlafon/ansible-profile/master/callback_plugins/profile_tasks.py</div><div class="line">edit /etc/ansible/ansible.cfg</div><div class="line">#callback_whitelist = timer, mail =&gt; callback_whitelist = profile_tasks</div></pre></td></tr></table></figure></p>
<p>先在执行 ansible-playbook 既可以看到每个 tasks 的用时情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">PLAY RECAP *********************************************************************</div><div class="line">172.16.11.210              : ok=2    changed=0    unreachable=0    failed=0   </div><div class="line">172.16.11.211              : ok=2    changed=0    unreachable=0    failed=0   </div><div class="line"></div><div class="line">Sunday 18 September 2016  16:03:26 +0800 (0:00:00.204)       0:00:07.061 ******</div><div class="line">===============================================================================</div><div class="line">setup ------------------------------------------------------------------- 6.82s</div><div class="line">print phone records ----------------------------------------------------- 0.20s</div></pre></td></tr></table></figure></p>
<h2 id="关闭-gathering-facts"><a href="#关闭-gathering-facts" class="headerlink" title="关闭 gathering facts"></a>关闭 gathering facts</h2><p>在执行 ansible-playbook 的过程中，ansible-playbook 第一步骤总是执行 gather_facts，不论你是否在 playbook 中定义这个 tasks。如果执行 playbook 不需要 fact 的数据，可以关闭 fact 数据功能，以加快 ansible-playbook 的执行速度。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 在 playbook 中关闭 facts,只需要添加 `gather_facts: no`</div><div class="line">---</div><div class="line">- hosts: 172.16..11.210</div><div class="line">  gather_facts: no</div><div class="line">  remote_user: root</div></pre></td></tr></table></figure></p>
<p>关闭执行继续执行上面的 playbook,效果十分明显<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PLAY RECAP *********************************************************************</div><div class="line">172.16.11.210              : ok=1    changed=0    unreachable=0    failed=0   </div><div class="line">172.16.11.211              : ok=1    changed=0    unreachable=0    failed=0   </div><div class="line"></div><div class="line">Sunday 18 September 2016  16:12:05 +0800 (0:00:00.195)       0:00:00.235 ******</div><div class="line">===============================================================================</div><div class="line">print phone records ----------------------------------------------------- 0.20s</div></pre></td></tr></table></figure></p>
<h2 id="SSH-PIPElinING"><a href="#SSH-PIPElinING" class="headerlink" title="SSH PIPElinING"></a>SSH PIPElinING</h2><p>SSH PIPElinING 是一个加速 Ansible 执行速度的简单方法。SSH PIPElinING 默认是关闭的，因为要兼容不同的 sudo 配置，主要是 requiretty 选项。如果不适用 sudo 建议开启。打开此选项可以减少 ansible 执行没有传输时 ssh 在被控机器上执行任务的连接数，如果使用 sudo，必须关闭 requiretty 选项， 修改 <code>/etc/ansible/ansible.cfg</code> 开启 pipelineing<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pipelining=False =&gt;   pipelining=True</div></pre></td></tr></table></figure></p>
<h2 id="ControlPersist"><a href="#ControlPersist" class="headerlink" title="ControlPersist"></a>ControlPersist</h2><p>ControlPersist 特性需要高版本的 SSH 才支持，CentOS 6 默认是不支持的，如果需要使用，需要自行升级 openssh。ControlPersist 即持久化 socket，一次验证，多次通信。并且只需要修改 ssh 客户端就行，也就是 Ansible 机器即可。<br>升级 openssh 的过程这里不做介绍。这里只介绍下 ControlPersist 设置的办法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">cat ~/.ssh/config</div><div class="line"> Host *</div><div class="line">  Compression yes</div><div class="line">  ServerAliveInterval 60</div><div class="line">  ServerAliveCountMax 5</div><div class="line">  ControlMaster auto</div><div class="line">  ControlPath ~/.ssh/sockets/%r@%h-%p</div><div class="line">  ControlPersist 4h</div></pre></td></tr></table></figure></p>
<p>在开启了 ControlPersist 特性后，SSH 在建立了 sockets 之后，节省了每次验证和创建的时间。在网络状况不是特别理想，尤其是跨互联网的情况下，所带来的性能提升是非常可观的。有这边需求的，试试就知道了。</p>
<h1 id="ansible-playbook-技巧"><a href="#ansible-playbook-技巧" class="headerlink" title="ansible-playbook 技巧"></a>ansible-playbook 技巧</h1><h2 id="获取命令行输出"><a href="#获取命令行输出" class="headerlink" title="获取命令行输出"></a>获取命令行输出</h2><p>在使用 ansible-playbook 中，当使用 common 或者 shell 模块执行自定义脚本，这些脚本都会有输出，用来表示执行正常或者是失败，在 ansible-playbook 中， 可以使用 register 来存储执行命令输出结果，将结果保存到变量中，在通过访问这个变量来获取输出结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">---                    </div><div class="line">- hosts: all           </div><div class="line">  gather_facts: no     </div><div class="line">  tasks:               </div><div class="line">    - name: echo date  </div><div class="line">      command: date    </div><div class="line">      register: date_output</div><div class="line">    - name: echo data_output</div><div class="line">      command: echo 30</div><div class="line">      notify: Hello      </div><div class="line">      when: date_output.stdout.split(&apos; &apos;)[2] == &quot;18&quot;</div><div class="line">  handlers:            </div><div class="line">    - name: Hello        </div><div class="line">      debug: msg=&quot;Hello&quot;</div></pre></td></tr></table></figure></p>
<h2 id="delegate-to-任务委派"><a href="#delegate-to-任务委派" class="headerlink" title="delegate_to 任务委派"></a>delegate_to 任务委派</h2><p>当要在 A 组服务器上执行 playbook 时，需要同时在另外一个不在 A 组的　B 服务器上执行另外操作，这里就可以使用 delegate_to 功能，用来委派任务给 B 服务器。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tasks:</div><div class="line">  - name: add host records</div><div class="line">    shell: &apos;echo &quot;172.16.11.1 api.abc.com&quot; &gt;&gt; /etc/hosts&apos;</div><div class="line">  - name: add hosts records to center Server</div><div class="line">    shell: ‘echo &quot;172.16.11.1 api.abc.com&quot; &gt;&gt; /etc/hosts’</div><div class="line">    delegate_to: 172.16.11.211</div></pre></td></tr></table></figure></p>
<h2 id="本地操作功能"><a href="#本地操作功能" class="headerlink" title="本地操作功能"></a>本地操作功能</h2><p>ansible 默认只会对定义好的被控机执行命令，如果要在本地也执行操作，可以使用 delegate_to 功能，当然还有另外一种更好的方式：<code>local_action</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// local_action</div><div class="line">- name: add host record to center server</div><div class="line">  local_action: shell &apos;echo &quot;192.168.1.100 test.xyz.com &quot; &gt;&gt; /etc/hosts&apos;</div><div class="line">// 当然您也可以使用 connection:local</div><div class="line">- name: add host record to center server</div><div class="line">  shell: &apos;echo &quot;192.168.1.100 test.xyz.com &quot; &gt;&gt; /etc/hosts&apos;</div></pre></td></tr></table></figure></p>
<h2 id="check-模式"><a href="#check-模式" class="headerlink" title="check 模式"></a>check 模式</h2><p>使用 check 参数运行 ansible-playbook时，不会对远端主机做任何操作，并带有检测功能，报告 playbook 会对主机做出什么操作。如果 playbook 中带有执行条件，检查就会出错了。</p>
<h2 id="使用-tag-来选择性执行"><a href="#使用-tag-来选择性执行" class="headerlink" title="使用 tag 来选择性执行"></a>使用 tag 来选择性执行</h2><p>可能由于某些原因， 在一个大型的 playbook 中，只想执行其中的特定部分，这样就会用到 tag 功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- name: yun install package</div><div class="line">  yum: name=&#123;&#123; item &#125;&#125; state=installed</div><div class="line">  with_items:</div><div class="line">     - httpd</div><div class="line">     - memcached</div><div class="line">  tags:</div><div class="line">     - packages</div><div class="line"></div><div class="line">- name: configuration modity</div><div class="line">  template: src=templates/src.j2 dest=/etc/foo.conf</div><div class="line">  tags:</div><div class="line">      - configuration</div></pre></td></tr></table></figure></p>
<p>如果你只想运行 playbook 中的 <code>configuration</code> 和 <code>packages</code>，你可以这样做<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ansible-playbook example.yml -tags “configuration,packages”</div></pre></td></tr></table></figure></p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>ansible 默认会检查命令和模块的返回状态，并进行相应的错误处理，默认遇到错误就会中断执行 playbook，当然这些是可以更改的</p>
<ul>
<li>忽略错误</li>
</ul>
<p>common 和 shell 模块执行的命令如果返回非零的状态码则 ansible 判断模块执行失败，通过 <code>ignore_errors</code> 忽略返回码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- name: this will not be counted as a filure</div><div class="line">  command: /bin/false</div><div class="line">  ignore_errors: true</div></pre></td></tr></table></figure></p>
<ul>
<li>自定义错误判定条件</li>
</ul>
<p>命令不依赖返回状态码来判定是否执行失败，而是要查看命令返回内容来决定，比如返回内容中包括 failed 字符串，则判定为失败。示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">- name: this command prints FAILED when it fails</div><div class="line">  command: /usr/bin/example-command -x -y -z</div><div class="line">  register: command_result</div><div class="line">  failed_when: &quot;&apos;FAILED&apos; in command_result.stderr&quot;</div></pre></td></tr></table></figure></p>
<p>ansible 会自动判断模块执行状态，command、shell 及其它模块如果修改了远程主机状态则被判定为 change 状态，不过也可以自己决定达到 changed 状态的条件，示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- name: copy in nginx conf</div><div class="line">  template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf</div><div class="line"></div><div class="line">- name: validate nginx conf</div><div class="line">  shell: &quot;/data/app/nginx/sbin/nginx -t&quot;</div><div class="line">  register: command_result</div><div class="line">  changed_when: command_result.stdout.find(&apos;successful&apos;)</div></pre></td></tr></table></figure></p>
<p>命令返回中有“successful”字符串，则为 changed 状态，下面这个设定将永远也不会达到 changed 状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- name: validate nginx conf</div><div class="line">  shell: &quot;/data/app/nginx/sbin/nginx -t&quot;</div><div class="line">  changed_when: false</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Ansible-性能优化&quot;&gt;&lt;a href=&quot;#Ansible-性能优化&quot; class=&quot;headerlink&quot; title=&quot;Ansible 性能优化&quot;&gt;&lt;/a&gt;Ansible 性能优化&lt;/h1&gt;&lt;p&gt;在使用 Ansible 过程中，当管理的服务器数量增加，就会
    
    </summary>
    
      <category term="运维自动化" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="Ansible" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/Ansible/"/>
    
    
      <category term="ansible" scheme="http://czero000.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Ansible--循环</title>
    <link href="http://czero000.github.io/2016/10/19/ansible-loop.html"/>
    <id>http://czero000.github.io/2016/10/19/ansible-loop.html</id>
    <published>2016-10-19T06:33:13.000Z</published>
    <updated>2016-10-19T09:17:15.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><p>Ansible的循环也与编程语言中的类似，循环可以帮你重复做一件事，直到它收到某一个特定结果。</p>
<h2 id="标准循环"><a href="#标准循环" class="headerlink" title="标准循环"></a>标准循环</h2><ul>
<li>简写重复的任务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- name: add server users</div><div class="line">  user: name=&#123;&#123; item &#125;&#125; state=present group=wheel</div><div class="line">  with_items:</div><div class="line">    - testuser1</div><div class="line">    - testuser2</div></pre></td></tr></table></figure>
<ul>
<li>变量中使用 YAML 列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 在变量中使用 YAML 列表</div><div class="line">with_itm_items: &quot;&#123;&#123; somelist &#125;&#125;&quot;</div><div class="line"></div><div class="line">// 等同于</div><div class="line">- name: add_user testuser1</div><div class="line">  user: name=testuser1 state=present group=wheel</div><div class="line">- name: add_user testuser2</div><div class="line">  user: name=testuser2 state=present group=wheel</div><div class="line"></div><div class="line">// 支持哈希列表</div><div class="line">- name: add serveral user</div><div class="line">  user: name=&#123;&#123; item.name &#125;&#125; state=present groups=&#123;&#123; item.groups &#125;&#125;</div><div class="line">  with_itm_items:</div><div class="line">    - &#123; name: &apos;testuser1&apos;, groups: &apos;wheel&apos; &#125;</div><div class="line">    - &#123; name: &apos;testuser2&apos;, groups: &apos;root&apos;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- name: give users access to multiple databases</div><div class="line">  mysql_user: name=&#123;&#123; item[0] &#125;&#125; priv=&#123;&#123; item[1] &#125;&#125;.*:ALL append_privs=yes password=foo</div><div class="line">  with_nested:</div><div class="line">    - [ &apos;alice&apos;, &apos;bob&apos;]</div><div class="line">    - [ &apos;clientdb&apos;, &apos;employeedb&apos;, &apos;providerdb&apos;]</div></pre></td></tr></table></figure>
<p>或者<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- name: here. &apos;users&apos; contains the above list of employees</div><div class="line">  mysql_user: name=&#123;&#123; itme[0] &#125;&#125; priv=&#123;&#123; item[1] &#125;&#125;.*:ALL append_privs=yes password=foo</div><div class="line">  with_nested:</div><div class="line">    - &quot;&#123;&#123;users&#125;&#125;&quot;</div><div class="line">    - [ &apos;clientdb&apos;, &apos;employeedb&apos;, &apos;providerdb&apos; ]</div></pre></td></tr></table></figure></p>
<h2 id="对哈希表使用循环"><a href="#对哈希表使用循环" class="headerlink" title="对哈希表使用循环"></a>对哈希表使用循环</h2><p>使用 <code>with_dict</code> 来循环哈希表中的元素,下面打印用户名和电话号码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: all</div><div class="line">  vars:</div><div class="line">    users:</div><div class="line">      alice:</div><div class="line">        name: Alice Appleworth</div><div class="line">        telephone: 123-456-789</div><div class="line">      bob:</div><div class="line">        name: Bob Bananarama</div><div class="line">        telephone: 987-654-321</div><div class="line">  tasks:</div><div class="line">    - name: print phone records</div><div class="line">      debug: msg=&quot;User &#123;&#123; item.key &#125;&#125; is &#123;&#123; item.value.name &#125;&#125; (&#123;&#123; item.value.telephone &#125;&#125;]&quot;</div><div class="line">      with_dict: &quot;&#123;&#123;users&#125;&#125;&quot;</div></pre></td></tr></table></figure></p>
<h2 id="对文件列表使用循环"><a href="#对文件列表使用循环" class="headerlink" title="对文件列表使用循环"></a>对文件列表使用循环</h2><p>使用 <code>with_fileglob</code> 可以以非递归的方式来匹配单个目录的文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: all</div><div class="line">  tasks:</div><div class="line">    # first ensure out target directory exists</div><div class="line">    - file: dest=/tmp/fooapp state=directory</div><div class="line">    # copy each file over that matches the given pattern</div><div class="line">    - copy: src=&#123;&#123; item &#125;&#125; dest=/tmp/fooapp/ owner=root mode=600</div><div class="line">      with_fileglob:</div><div class="line">        - /opt/ansible/playbooks/fooapp/*</div></pre></td></tr></table></figure></p>
<h2 id="对并行数据使用循环"><a href="#对并行数据使用循环" class="headerlink" title="对并行数据使用循环"></a>对并行数据使用循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// 变量</div><div class="line">alpha: [&apos;a&apos;, &apos;b&apos;, &apos;c&apos; &apos;d&apos; ]</div><div class="line">numbers: [ 1, 2, 3, 4 ]</div><div class="line">// 得到 &apos;(a,1)&apos; 和 ‘(b,2)’,可以使用`with_together`</div><div class="line">tasks:</div><div class="line">  - debug: msg=&quot;&#123;&#123; item.0 &#125;&#125; and &#123;&#123; item.1 &#125;&#125;&quot;</div><div class="line">    with_together:</div><div class="line">      - &quot;&#123;&#123; alpha &#125;&#125;&quot;</div><div class="line">      - &quot;&#123;&#123; numbers &#125;&#125;&quot;</div></pre></td></tr></table></figure>
<h2 id="对子元素使用循环"><a href="#对子元素使用循环" class="headerlink" title="对子元素使用循环"></a>对子元素使用循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">---          </div><div class="line">- name: create user</div><div class="line">  hosts: all</div><div class="line">  vars:      </div><div class="line">    users:   </div><div class="line">      - name: alice</div><div class="line">        authorized:</div><div class="line">          - /tmp/alice/onekey.pub</div><div class="line">          - /tmp/alice/twokey.pub</div><div class="line">        mysql:</div><div class="line">          password: mysql-password</div><div class="line">          hosts:</div><div class="line">            - &quot;%&quot;</div><div class="line">            - &quot;127.0.0.1&quot;</div><div class="line">            - &quot;::1&quot;</div><div class="line">            - &quot;localhost&quot;</div><div class="line">          privs:</div><div class="line">            - &quot;*.*:SELECT&quot;</div><div class="line">            - &quot;DB1.*:ALL&quot;</div><div class="line">      - name: bob</div><div class="line">        authrized:</div><div class="line">          - /tmp/bob/id_rsa.pub</div><div class="line">        mysql:</div><div class="line">          password: other-mysql-password</div><div class="line">          hosts:</div><div class="line">            - &quot;db1&quot;</div><div class="line">          privs:</div><div class="line">            - &quot;*.*:SELECT&quot;</div><div class="line">            - &quot;DB2.*:ALL&quot;</div></pre></td></tr></table></figure>
<p>对子元素使用循环<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- user: name=&#123;&#123; item.name &#125;&#125; state=present generate_ssh_key=yes</div><div class="line">  with_items: &quot;&#123;&#123;users&#125;&#125;&quot;</div><div class="line"></div><div class="line">- authorized_key: &quot;user=&#123;&#123; item.0.name &#125;&#125; key=&apos;&#123;&#123; lookup(&apos;file&apos;, item.1) &#125;&#125;&apos;&quot;</div><div class="line">  with_subelements:</div><div class="line">     - users</div><div class="line">     - authorized</div></pre></td></tr></table></figure></p>
<p>根据mysql hosts以及预先给定的privs subkey列表,我们也可以在嵌套的subkey中迭代列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- name: Setup MySQL users</div><div class="line">  mysql_user: name=&#123;&#123; item.0.user &#125;&#125; password=&#123;&#123; item.0.mysql.password &#125;&#125; host=&#123;&#123; item.1 &#125;&#125; priv=&#123;&#123; item.0.mysql.privs | join(&apos;/&apos;) &#125;&#125;</div><div class="line">  with_subelements:</div><div class="line">    - users</div><div class="line">    - mysql.hosts</div></pre></td></tr></table></figure></p>
<h2 id="对整数数组使用循环"><a href="#对整数数组使用循环" class="headerlink" title="对整数数组使用循环"></a>对整数数组使用循环</h2><p><code>with-sequence</code> 可以以升序拍了生成一组序列，可以指定起始、终止及步长<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">- hosts: all</div><div class="line"></div><div class="line">  tasks:</div><div class="line"></div><div class="line">    # create groups</div><div class="line">    - group: name=evens state=present</div><div class="line">    - group: name=odds state=present</div><div class="line"></div><div class="line">    # create some test users</div><div class="line">    - user: name=&#123;&#123; item &#125;&#125; state=present groups=evens</div><div class="line">      with_sequence: start=0 end=32 format=testuser%02x</div><div class="line"></div><div class="line">    # create a series of directories with even numbers for some reason</div><div class="line">    - file: dest=/var/stuff/&#123;&#123; item &#125;&#125; state=directory</div><div class="line">      with_sequence: start=4 end=16 stride=2</div><div class="line"></div><div class="line">    # a simpler way to use the sequence plugin</div><div class="line">    # create 4 groups</div><div class="line">    - group: name=group&#123;&#123; item &#125;&#125; state=present</div><div class="line">      with_sequence: count=4</div></pre></td></tr></table></figure></p>
<h2 id="随机选择"><a href="#随机选择" class="headerlink" title="随机选择"></a>随机选择</h2><p><code>random_choice</code> 可以随机获取值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- debug: msg=&#123;&#123; item &#125;&#125;</div><div class="line">  with_random_choice:</div><div class="line">     - &quot;go through the door&quot;</div><div class="line">     - &quot;drink from the goblet&quot;</div><div class="line">     - &quot;press the red button&quot;</div><div class="line">     - &quot;do nothing&quot;</div></pre></td></tr></table></figure></p>
<h2 id="Do-Until-循环"><a href="#Do-Until-循环" class="headerlink" title="Do-Until 循环"></a>Do-Until 循环</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- action: shell /usr/bin/foo</div><div class="line">  register: result</div><div class="line">  until: result.stdout.find(&quot;all systems go&quot;) != -1</div><div class="line">  retries: 5</div><div class="line">  delay: 10</div></pre></td></tr></table></figure>
<p>直到结果的stdout输出包含<code>all systems go</code> 或者经过重复 5 次任务</p>
<h2 id="查找匹配文件"><a href="#查找匹配文件" class="headerlink" title="查找匹配文件"></a>查找匹配文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">- name: INTERFACES | Create Ansible header for /etc/network/interfaces</div><div class="line">  template: src=&#123;&#123; item &#125;&#125; dest=/etc/foo.conf</div><div class="line">  with_first_found:</div><div class="line">    - &quot;&#123;&#123;ansible_virtualization_type&#125;&#125;_foo.conf&quot;</div><div class="line">    - &quot;default_foo.conf&quot;</div></pre></td></tr></table></figure>
<p>可以用于搜索路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- name: some configuration template</div><div class="line">  template: src=&#123;&#123; item &#125;&#125; dest=/etc/file.cfg mode=0444 owner=root group=root</div><div class="line">  with_first_found:</div><div class="line">    - files:</div><div class="line">       - &quot;&#123;&#123;inventory_hostname&#125;&#125;/etc/file.cfg&quot;</div><div class="line">      paths:</div><div class="line">       - ../../../templates.overwrites</div><div class="line">       - ../../../templates</div><div class="line">    - files:</div><div class="line">        - etc/file.cfg</div><div class="line">      paths:</div><div class="line">        - templates</div></pre></td></tr></table></figure></p>
<h2 id="迭代执行结果"><a href="#迭代执行结果" class="headerlink" title="迭代执行结果"></a>迭代执行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- name: Example of looping over a REMOTE command result</div><div class="line">  shell: /usr/bin/something</div><div class="line">  register: command_result</div><div class="line"></div><div class="line">- name: Do something with each result</div><div class="line">  shell: /usr/bin/something_else --param &#123;&#123; item &#125;&#125;</div><div class="line">  with_items: &quot;&#123;&#123;command_result.stdout_lines&#125;&#125;&quot;</div></pre></td></tr></table></figure>
<h2 id="循环列表"><a href="#循环列表" class="headerlink" title="循环列表"></a>循环列表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- name: indexed loop demo</div><div class="line">  debug: msg=&quot;at array position &#123;&#123; item.0 &#125;&#125; there is a value &#123;&#123; item.1 &#125;&#125;&quot;</div><div class="line">  with_indexed_items: &quot;&#123;&#123;some_list&#125;&#125;&quot;</div></pre></td></tr></table></figure>
<h2 id="循环配置文件"><a href="#循环配置文件" class="headerlink" title="循环配置文件"></a>循环配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">// 使用 ini 插件</div><div class="line">- debug: msg=&quot;&#123;&#123;item&#125;&#125;&quot;</div><div class="line">  with_ini: value[1-2] section=section1 file=lookup.ini re=true</div></pre></td></tr></table></figure>
<h2 id="在循环中是用注册器"><a href="#在循环中是用注册器" class="headerlink" title="在循环中是用注册器"></a>在循环中是用注册器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">- hosts: 172.16.11.210  </div><div class="line">  name: test loop register</div><div class="line">  remote_user: root     </div><div class="line">  tasks:                </div><div class="line">    - name: test loop register</div><div class="line">      shell: /bin/echo &quot;&#123;&#123; item &#125;&#125;&quot;</div><div class="line">      with_items:       </div><div class="line">        - Hello         </div><div class="line">        - World         </div><div class="line">      register: echo_result</div><div class="line">      #- debug: msg=&quot;&#123;&#123; echo_result.results &#125;&#125;&quot;</div><div class="line"></div><div class="line">    - name: Fail if return code is not 0</div><div class="line">      debug: msg=&quot;The command (&#123;&#123; item.cmd &#125;&#125;) did not have a 0 return code.&quot;</div><div class="line">      when: item.rc != 0                                                                                                                                    </div><div class="line">      with_items: &quot;&#123;&#123; echo_result.results &#125;&#125;&quot;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;循环&quot;&gt;&lt;a href=&quot;#循环&quot; class=&quot;headerlink&quot; title=&quot;循环&quot;&gt;&lt;/a&gt;循环&lt;/h1&gt;&lt;p&gt;Ansible的循环也与编程语言中的类似，循环可以帮你重复做一件事，直到它收到某一个特定结果。&lt;/p&gt;
&lt;h2 id=&quot;标准循环&quot;&gt;&lt;a h
    
    </summary>
    
      <category term="运维自动化" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="Ansible" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/Ansible/"/>
    
    
      <category term="ansible" scheme="http://czero000.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>Ansible-入门</title>
    <link href="http://czero000.github.io/2016/10/19/rudiments-of-nsible.html"/>
    <id>http://czero000.github.io/2016/10/19/rudiments-of-nsible.html</id>
    <published>2016-10-19T06:20:11.000Z</published>
    <updated>2016-10-19T09:17:15.092Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-Ansible"><a href="#什么是-Ansible" class="headerlink" title="什么是 Ansible"></a>什么是 Ansible</h1><p>Ansible 是基于 python 的配置管理和应用部署工具。官方给的 title是 “Ansible is Simple IT Automation” —简单的自动化IT工具。</p>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="http://czero000.github.io/images/ansible/ansible.png" alt="ansible架构图" title="ansible架构图"></p>
<h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p><img src="http://czero000.github.io/images/ansible/ansible-work.png" alt="工作原理" title="ansible工作原理"></p>
<ul>
<li>管理端支持 local、 ssh、zeromq 三种方式连接被控端，默认使用 ssh</li>
<li>可以按照一定规则进行 inventory，管理节点通过模块实现对应操作–ad-hoc</li>
<li>管理节点可以通过 playbook 实现对多个 task 的集合实现一类功能</li>
</ul>
<h1 id="安装-Ansible"><a href="#安装-Ansible" class="headerlink" title="安装 Ansible"></a>安装 Ansible</h1><ul>
<li>源码安装</li>
</ul>
<p>源码安装需要 python2.6 以上版本，依赖 paramiko， PyYAML， Jinja2， simplejsion、 pycrypto模块，可以通过 pip 来安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 获取源码</div><div class="line">git clone git://github.com/ansible/ansible.git --recursive   </div><div class="line">cd ./ansible</div><div class="line"></div><div class="line">// 设置环境变量</div><div class="line">source ./hacking/env-setup</div><div class="line">source ./hacking/env-setup.fish</div><div class="line">source ./hacking/env-setup -q</div><div class="line"></div><div class="line">// 安装 Python 依赖</div><div class="line">easy_install pip</div><div class="line">pip install paramiko PyYAML Jinja2 httplib2 six</div><div class="line"></div><div class="line">// 更新 Ansible</div><div class="line">git pull --rebase</div><div class="line">git submodule update --init --recursive</div><div class="line"></div><div class="line">// 设置inventory文件</div><div class="line">echo &quot;127.0.0.1&quot; &gt; ~/ansible_hosts</div><div class="line">export ANSIBLE_HOSTS=~/ansible_hosts</div><div class="line"></div><div class="line">// 测试命令</div><div class="line">ansible all -m ping --ask-pass</div></pre></td></tr></table></figure></p>
<ul>
<li>常用 Linux　发行版</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// CentOS、RHEL</div><div class="line">yum install ansible</div><div class="line"></div><div class="line">//Ubuntu、Debian</div><div class="line">sudo apt-get install software-properties-common</div><div class="line">sudo apt-add-repository ppa:ansible/ansible</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install ansible</div></pre></td></tr></table></figure>
<ul>
<li>通过 pip 安装最新版<br>Ansible 可以通过  <code>pip</code> 安装,同时也会安装 paramiko、PyYAML、jinja2 等 Python 依赖库。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">apt install python3-pip</div><div class="line">pip3 install ansible</div></pre></td></tr></table></figure>
<h1 id="运行-Ansible"><a href="#运行-Ansible" class="headerlink" title="运行 Ansible"></a>运行 Ansible</h1><h2 id="添加被控远程主机清单"><a href="#添加被控远程主机清单" class="headerlink" title="添加被控远程主机清单"></a>添加被控远程主机清单</h2><p>已经安装好了 Ansible ，先在就可以运行 Ansible 了。 首先要在 <code>/etc/ansible/hosts</code> 文件中加入一个或者多个远程 ip 或者 domain。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">172.16.11.210</div><div class="line">172.16.11.211</div></pre></td></tr></table></figure>
<h2 id="配置基于-SSH-key-方式-连接"><a href="#配置基于-SSH-key-方式-连接" class="headerlink" title="配置基于 SSH key 方式 连接"></a>配置基于 SSH key 方式 连接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 主控端操作</div><div class="line">ssh-keygen -t rsa -q</div><div class="line">ssh-copy-id 172.16.11.210</div><div class="line">ssh-copy-id 172.16.11.211</div></pre></td></tr></table></figure>
<h2 id="运行-Ansible-1"><a href="#运行-Ansible-1" class="headerlink" title="运行 Ansible"></a>运行 Ansible</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ansible all -m ping</div><div class="line">172.16.11.210 | SUCCESS =&gt; &#123;</div><div class="line">    &quot;changed&quot;: false,</div><div class="line">    &quot;ping&quot;: &quot;pong&quot;</div><div class="line">&#125;</div><div class="line">172.16.11.211 | SUCCESS =&gt; &#123;</div><div class="line">    &quot;changed&quot;: false,</div><div class="line">    &quot;ping&quot;: &quot;pong&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="配置-inventory"><a href="#配置-inventory" class="headerlink" title="配置 inventory"></a>配置 inventory</h1><p>Ansible 可以同时操纵属于一个组的多台主机，主机和组的关系是通过 inventory 文件来配置即<code>/etc/ansible/hosts</code>。<br>inventory可以通过 IP、Domain 来指定，未分组的机器要保留在 host 文件顶部，通过<code>[]</code> 来配置分组信息。</p>
<h2 id="主机与组"><a href="#主机与组" class="headerlink" title="主机与组"></a>主机与组</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">// 简单分组</div><div class="line">[web1]</div><div class="line">web210.example.com</div><div class="line">web211.example.com</div><div class="line"></div><div class="line">// 配置端口号</div><div class="line">[web2]</div><div class="line">172.16.11.210:8000</div><div class="line">172.16.11.211:8000</div><div class="line"></div><div class="line">// 定义别名和端口</div><div class="line">[web]</div><div class="line">www ansible_ssh_port=1234 ansible_ssh_host=172.16.11.211  ansible_ssh_pass=passwd \\ 远程ip，ssh登陆用户、密码</div><div class="line">other1  ansible_connertion=ssh ansible_ssh_user = illlusion</div><div class="line"></div><div class="line">//执行主机，支持正则表达</div><div class="line">[web_www]</div><div class="line">www[01:10].example.com</div><div class="line">db-[a:f].erample.com</div></pre></td></tr></table></figure>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">// 主机变量，分配变量给主机，这些变量可以在之后的 playbook 中使用</div><div class="line">[web-www]</div><div class="line">www-a http_port=89 maxRequestsPerChild=808</div><div class="line">www-a http_port=303 maxRequestsPerChild=909</div><div class="line"></div><div class="line">//组的变量，组也可以赋予变量，这样组成员将继承组变量</div><div class="line"></div><div class="line">[web-www]</div><div class="line">www-a http_port=89 maxRequestsPerChild=808</div><div class="line">www-a http_port=303 maxRequestsPerChild=909</div><div class="line"></div><div class="line">[web-www:vars]</div><div class="line">ntp_server=ntp.example.com</div><div class="line">proxy=proxy.example.com</div><div class="line"></div><div class="line">// 组嵌套 可以把组作为另外一个组的子成员，已经分配变量给整个组使用。这些变量可以给 `/usr/bin/ansible-playbook` 使用，但是不能给 `/usr/bin/ansible` 使用</div><div class="line"></div><div class="line">[group1]</div><div class="line">host1</div><div class="line">host2</div><div class="line"></div><div class="line">[group2]</div><div class="line">host3</div><div class="line">host4</div><div class="line"></div><div class="line">[group3:children]</div><div class="line">group1</div><div class="line">group2</div><div class="line"></div><div class="line">[group3:vars]</div><div class="line">some_server=foo.example.com</div><div class="line">halon_system_timeout=30</div><div class="line">self_destruct_countdown=60</div><div class="line">escape_pods=2</div></pre></td></tr></table></figure>
<h2 id="分文件定义-Host-和-group-变量"><a href="#分文件定义-Host-和-group-变量" class="headerlink" title="分文件定义 Host 和 group 变量"></a>分文件定义 Host 和 group 变量</h2><p>在 inventory 文件中保存的所有变量并不是最佳方式，还可以保存在独立的文件中， 这些文件与 inventory 关联，要求使用 <code>YAML</code>语法。host 和 gourp 变量 要求存储在与 host 和 group 相同的目录名中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//假设有一个 host 为 foosball 主机，属于两个组，一个是 raleigh,另外一个是 webserver</div><div class="line">/etc/ansible/group_vars/raleigh</div><div class="line">/etc/ansible/group_vars/webservers</div><div class="line">/etc/ansible/host_vars/foosball</div><div class="line"></div><div class="line">// raleigh 组的变量</div><div class="line">ntp_server: acme.example.org</div><div class="line">database_server: storage.example.org</div></pre></td></tr></table></figure></p>
<p>还可以在组变量目录下创建多个文件，设置不同类型的变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/etc/ansible/group_vars/raleigh/db_settings</div><div class="line">/etc/ansible/group_vars/raleigh/cluster_settings</div></pre></td></tr></table></figure></p>
<h2 id="inventory-参数说明"><a href="#inventory-参数说明" class="headerlink" title="inventory 参数说明"></a>inventory 参数说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">// 要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置.</div><div class="line">ansible_ssh_host</div><div class="line"></div><div class="line">// ssh 端口号.如果不使用默认,通过此变量设置.</div><div class="line">ansible_ssh_port</div><div class="line"></div><div class="line">// ssh 用户名</div><div class="line">ansible_ssh_user</div><div class="line"></div><div class="line">// ssh 密码(这种明文方式并不安全,强烈建议使用 --ask-pass 或 SSH 密钥)</div><div class="line">ansible_ssh_pass</div><div class="line"></div><div class="line">// sudo 密码(这种方式并不安全,强烈建议使用 --ask-sudo-pass)</div><div class="line">ansible_sudo_pass</div><div class="line"></div><div class="line">// sudo 命令路径(适用于1.8及以上版本)</div><div class="line">ansible_sudo_exe (new in version 1.8)</div><div class="line"></div><div class="line">// 与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 &apos;smart&apos;,&apos;smart&apos; 方式会根据是否支持 ControlPersist, 来判断&apos;ssh&apos; 方式是否可行.</div><div class="line">ansible_connection</div><div class="line"></div><div class="line">// ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况.</div><div class="line">ansible_ssh_private_key_file</div><div class="line"></div><div class="line">// 目标系统的 shell 类型.默认情况下,命令的执行使用 &apos;sh&apos; 语法,可设置为 &apos;csh&apos; 或 &apos;fish&apos;.      </div><div class="line">ansible_shell_type</div><div class="line"></div><div class="line">// 目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如  \*BSD, 或者 /usr/bin/python      </div><div class="line">ansible_python_interpreter</div></pre></td></tr></table></figure>
<h1 id="Patterns"><a href="#Patterns" class="headerlink" title="Patterns"></a>Patterns</h1><p>在 ansible 中， patterns 是指如何确定有那些主机或组被管理，在 playbook 中，它是指对应主机应用特定的配置或执行特定进程。</p>
<h2 id="ansible"><a href="#ansible" class="headerlink" title="ansible"></a>ansible</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 语法</div><div class="line">ansible &lt;pattern_goes_here&gt; -m &lt;module_name&gt; -a &lt;arguments&gt;</div><div class="line"></div><div class="line">// 示例</div><div class="line">ansible webservers -m service -a &quot;name=httpd state=restarted&quot;</div></pre></td></tr></table></figure>
<p>简单的说， pattern 是一个主机筛选器，支持正则匹配。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">// 所有主机</div><div class="line">all</div><div class="line">*</div><div class="line"></div><div class="line">//特定主机，支持 ip 地址和主机名</div><div class="line">web211</div><div class="line">172.16.11.211</div><div class="line"></div><div class="line">//主机组，可以指定特定组或多个组，多个组之间使用`:`分隔</div><div class="line">web_server</div><div class="line">web_server:database_server</div><div class="line"></div><div class="line">// 支持正则表达式和逻辑运算</div><div class="line">web_server:!web211</div><div class="line">web_server:&amp;db1</div><div class="line">web_server:database_server:&amp;db1:!web211</div></pre></td></tr></table></figure>
<h2 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h2><p>在 playbook 中，通过使用 <code>-e</code>参数可以实现通过变量来确定 group</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">webservers:!&#123;&#123;excluded&#125;&#125;:&amp;&#123;&#123;required&#125;&#125;</div><div class="line"></div><div class="line">// 通配符</div><div class="line">*.example.com</div><div class="line">*.com</div><div class="line"></div><div class="line">//通配符和正则同时</div><div class="line">one*.com:dbservers</div><div class="line"></div><div class="line">// 在 patterns 应用正则式时，使用 `~` 开头</div><div class="line">~(web|db).*\.example\.com</div><div class="line"></div><div class="line">// 索引和切片</div><div class="line">webservers[0]</div><div class="line">webservers[0-25]</div><div class="line"></div><div class="line">// 可以在使用 `--limit` 标记来添加排除条件</div><div class="line">ansible-playbook site.yml --limit datacenter2</div><div class="line"></div><div class="line">// 如果你想从文件读取 hosts,文件名以 @ 为前缀即可.</div><div class="line">ansible-playbook site.yml --limit @retry_hosts.txt</div></pre></td></tr></table></figure>
<h1 id="简单执行命令"><a href="#简单执行命令" class="headerlink" title="简单执行命令"></a>简单执行命令</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ansible  all -m ping</div><div class="line">172.16.11.210 | SUCCESS =&gt; &#123;</div><div class="line">    &quot;changed&quot;: false,</div><div class="line">    &quot;ping&quot;: &quot;pong&quot;</div><div class="line">&#125;</div><div class="line">172.16.11.211 | SUCCESS =&gt; &#123;</div><div class="line">    &quot;changed&quot;: false,</div><div class="line">    &quot;ping&quot;: &quot;pong&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可用该命令选项：</p>
<ul>
<li>-i：指定 inventory 文件，使用当前目录下的 hosts</li>
<li>all：针对 hosts 定义的所有主机执行，这里也可以指定组名或模式</li>
<li>-m：指定所用的模块，我们使用 Ansible 内置的 ping 模块来检查能否正常管理远端机器</li>
<li>-u：指定远端机器的用户</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">ansible all -m ping     \\ping 所有的节点</div><div class="line">ansible 127* -m ping</div><div class="line">ansible -i /etc/ansible/hosts -m command -a &quot;uptime&quot;  // 指定 pattens 文件</div><div class="line">ansible all -m ping -u test</div><div class="line">ansible all -m ping -u test --sudo</div><div class="line">ansible all -m ping -u test --sudo --sudo-user tom</div><div class="line">ansible testhost -m setup -a &quot;filter=ansible_all_ipv4_addresses&quot; \\使用 filter 过滤信息   </div><div class="line">ansible testhosts -a &quot;/sbin/reboot&quot; -f 10  \\重启testhosts组的所有机器，每次重启10台</div><div class="line">ansible testhosts -m copy -a &quot;src=/etc/hosts dest=/tmp/hosts&quot; \\拷贝本地hosts 文件到testhosts组所有主机的/tmp/hosts</div><div class="line">ansible webservers -m file -a &quot;dest=/srv/foo/a.txt mode=600&quot; \\file 模块允许更改文件的用户及权限</div><div class="line">ansible webservers -m file -a &quot;dest=/srv/foo/b.txt mode=600 owner=mdehaan group=mdehaan&quot;</div><div class="line">ansible webservers -m file -a &quot;dest=/path/to/c mode=755 owner=mdehaan group=mdehaan state=directory&quot; \\使用 file 模块创建目录，类似 mkdir -p</div><div class="line">ansible webservers -m file -a &quot;dest=/path/to/c state=absent&quot; \\file 模块允许更改文件的用户及权限  </div><div class="line">ansible testhosts -a &apos;cal&apos;  \\默认是使用 command 模块，所以使用command的命令时不用添加 -m</div><div class="line">ansible webhosts -m command -a &apos;date&apos; \\在 hosts 文件中的 webhosts 组下的所有主机都使用 date 命令</div><div class="line">ansible webhosts -m command -a &apos;ping&apos; \\在 hosts 文件中的 webhosts 组下的所有主机都使用 date 命令</div><div class="line">ansible testhosts -m service -a &quot;name=ntpd state=restarted&quot;</div><div class="line"></div><div class="line">使用 user 模块对于创建新用户和更改、删除已存在用户非常方便：</div><div class="line">ansible all -m user -a &quot;name=foo password=&lt;crypted password here&gt;&quot;</div><div class="line">ansible all -m user -a &quot;name=foo state=absent&quot;</div><div class="line"></div><div class="line">// 服务管理：</div><div class="line">ansible webservers -m service -a &quot;name=httpd state=restarted&quot; \\重启 webservers 组所有主机的 httpd 服务</div><div class="line">ansible webservers -m service -a &quot;name=httpd state=started&quot;  \\确保 webservers 组所有主机的 httpd 是启动的</div><div class="line">ansible webservers -m service -a &quot;name=httpd state=stopped&quot;  \\确保 webservers 组所有主机的 httpd 是关闭的</div><div class="line"></div><div class="line">//后台运行，长时间运行的操作可以放到后台执行，ansible 会检查任务的状态；在主机上执行的同一个任务会分配同一个 job ID</div><div class="line">ansible all -B 3600 -a &quot;/usr/bin/long_running_operation --do-stuff&quot; \\后台执行命令 3600s，-B 表示后台执行的时间</div><div class="line">ansible all -m async_status -a &quot;jid=123456789&quot;  \\检查任务的状态</div><div class="line">ansible all -B 1800 -P 60 -a &quot;/usr/bin/long_running_operation --do-stuff&quot; \\后台执行命令最大时间是 1800s 即 30 分钟，-P 每 60s 检查下状态默认 15s</div><div class="line"></div><div class="line">// 搜集系统信息</div><div class="line">ansible all -m setup \\搜集主机的所有系统信息</div><div class="line">ansible all -m setup --tree /tmp/facts \\搜集系统信息并以主机名为文件名分别保存在 /tmp/facts 目录</div><div class="line">ansible all -m setup -a &apos;filter=ansible_*_mb&apos; \\搜集和内存相关的信息</div><div class="line">ansible all -m setup -a &apos;filter=ansible_eth[0-2]&apos; \\搜集网卡信息</div></pre></td></tr></table></figure>
<h1 id="Ad-Hoc"><a href="#Ad-Hoc" class="headerlink" title="Ad-Hoc"></a>Ad-Hoc</h1><p>执行 Ad-Hoc 跟在 Linux 执行命令差不多， 用来快速完成简单的任务。</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ansible [host or group] -m  [module_name] -a [commond] [ ansible-options ]</div></pre></td></tr></table></figure>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li>执行安装程序， 安装 <code>python-simplejson</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ansible all -m raw -a &apos;yum -y install python-simplejson&apos;</div></pre></td></tr></table></figure>
<ul>
<li>重启 web 服务<br>假如 web_server 是一个组， 这里组里面有很多webserver，先在需要在 web_server 组上的左右机器执行 reboot 命令， -f 参数会 fork 出 10 个子进程，以并行的方式执行 reboot，即每次重启 10 台</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ansible web_server -a &quot;/sbin/reboot&quot; -f 10</div></pre></td></tr></table></figure>
<p>在执行时，默认是以当前用户身份去执行该命令，如果需要执行执行用户，添加 <code>-u username</code>，或者需要使用 sudo 去执行,添加 <code>-u username --sudo [--ask-sudo-pass]</code>。如果不是以 passwordless 的模式执行 sudo,应加上 –ask-sudo-pass (-K)选项,加上之后会提示你输入 密码.使用 passwordless 模式的 sudo, 更容易实现自动化,但不要求一定要使用 passwordless sudo.</p>
<ul>
<li>文件传输</li>
</ul>
<p>ansible 的另外一种用法就是可以以并行的方式同时 scp 大量的文件到多台主机。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ansible all -m copy -a &quot;src=/opt/ansible/test.txt dest=/opt/ansible/test.txt&quot;</div></pre></td></tr></table></figure>
<p>如果是用 playbook，择可以利用 template 模块来实现更高级操作。</p>
<p>使用 file 模块 可以修改文件的属主和权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ansible all -m file -a &apos;dest=/opt/ansible/test.txt mode=600 owner=nobody group=nobody&apos;</div></pre></td></tr></table></figure></p>
<p>使用 file 模块还可以创建、删除目录和文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 创建目录</div><div class="line">ansible all -m file -a &apos;dest=/opt/ansible/test mode=755 owner=root group=root state=directory&apos;</div><div class="line"></div><div class="line">// 删除目录和文件</div><div class="line">ansible all -m file -a &apos;dest=/opt/ansible/test state=absent&apos;</div></pre></td></tr></table></figure></p>
<p>更多详见<a href="http://docs.ansible.com/ansible/copy_module.html" target="_blank" rel="external">copy模块说明</a></p>
<ul>
<li>包管理</li>
</ul>
<p>ansible 提供了对 yum 和 apt 的支持<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> // 安装软件包</div><div class="line"> ansible all -m yum -a &apos;name=vim state=present&apos;</div><div class="line"></div><div class="line">// 卸载软件包</div><div class="line"> ansible all -m yum -a &apos;name=vim state=absent&apos;</div></pre></td></tr></table></figure></p>
<p>在不同的发行版的软件包管理软件， ansible 有其对应的模块， 如果没有，你可以使用 command 模块去安装软件。<br>更多详见<a href="http://docs.ansible.com/ansible/list_of_packaging_modules.html" target="_blank" rel="external">package模块说明</a></p>
<ul>
<li>用户和组管理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 创建用户</div><div class="line">ansible all -m user -a &apos;name=charlie password=123456 state=present&apos;</div><div class="line"></div><div class="line">// 修改用户， 增加属组和修改shell</div><div class="line">ansible all -m user -a &apos;name=Cc groups=nobody shell=/sbin/nologin state=present&apos;</div><div class="line"></div><div class="line">//移除用户</div><div class="line">ansible all -m user -a &apos;name=Cc state=absent&apos;</div></pre></td></tr></table></figure>
<p>更多参数详见<a href="http://docs.ansible.com/ansible/user_module.html" target="_blank" rel="external">user模块说明</a></p>
<ul>
<li>服务管理</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 启动服务</div><div class="line">ansible all -m service -a &apos;name=rsyslog state=started&apos;</div><div class="line">// 重启服务</div><div class="line">ansible all -m service -a &apos;name=rsyslog state=restarted&apos;</div><div class="line">// 停止服务</div><div class="line">ansible all -m service -a &apos;name=rsyslog state=stopped&apos;</div></pre></td></tr></table></figure>
<ul>
<li>系统自身变量获取</li>
</ul>
<p>ansible 可以通过 setup 模块来获取客户端自身的以便固有信息，叫做 facts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 获取所有 facts 变量</div><div class="line">ansible all -m setup</div><div class="line"></div><div class="line">// 通过 filter 获取某一个 fact 变量</div><div class="line">ansible all -m setup -a &apos;filter=ansible_*mb&apos;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-Ansible&quot;&gt;&lt;a href=&quot;#什么是-Ansible&quot; class=&quot;headerlink&quot; title=&quot;什么是 Ansible&quot;&gt;&lt;/a&gt;什么是 Ansible&lt;/h1&gt;&lt;p&gt;Ansible 是基于 python 的配置管理和应用部署工具。官方
    
    </summary>
    
      <category term="运维自动化" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="Ansible" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/Ansible/"/>
    
    
      <category term="ansible" scheme="http://czero000.github.io/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>搭建GitLab服务器</title>
    <link href="http://czero000.github.io/2016/10/19/build-gitlab.html"/>
    <id>http://czero000.github.io/2016/10/19/build-gitlab.html</id>
    <published>2016-10-19T06:00:16.000Z</published>
    <updated>2016-10-19T06:01:33.007Z</updated>
    
    <content type="html"><![CDATA[<p>﻿Gitlab 是一个基于 <code>Ruby on Rails</code> 开发的开源项目管理程序，可以通过 WEB 界面进行访问公开的或者私人项目，实现一个自托管的 Git 项目仓库。它拥有与 GitHub 类似的功能，可以浏览代码，管理缺陷和注释。</p>
<h2 id="安装依赖软件"><a href="#安装依赖软件" class="headerlink" title="安装依赖软件"></a>安装依赖软件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install curl openssh-server ca-certificates postfix</div></pre></td></tr></table></figure>
<h2 id="添加-GitLab仓库-安装软件包"><a href="#添加-GitLab仓库-安装软件包" class="headerlink" title="添加　GitLab仓库 ,安装软件包"></a>添加　GitLab仓库 ,安装软件包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -sS https://packages.gitlab.com/install/repositories/gitlab/gitlab-ce/script.deb.sh | sudo bash</div><div class="line">apt-get install gitlab-ce</div></pre></td></tr></table></figure>
<p>如果不习惯使用命令行管道的安装方式，官方提供了<a href="http://packages.gitlab.cc/install/gitlab-ce/" target="_blank" rel="external">安装脚本</a> 或者 <a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/" target="_blank" rel="external">手动下载相应平台及版本的软件包</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl -LJO https://packages.gitlab.com/gitlab/gitlab-ce/packages/ubuntu/xenial/gitlab-ce-XXX.deb/download</div><div class="line">dpkg -i gitlab-ce-XXX.deb</div></pre></td></tr></table></figure></p>
<p>如果访问速度慢，可以使用国内的镜像站如：<code>https://mirror.tuna.tsinghua.edu.cn/help/gitlab-ce/</code></p>
<h2 id="启动-GitLab"><a href="#启动-GitLab" class="headerlink" title="启动 GitLab"></a>启动 GitLab</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gitlab-cli reconfigure</div></pre></td></tr></table></figure>
<p>可以通过 <code>gitlab-clt status</code> 查看 GitLab 安装是否成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gitlab-ctl status</div><div class="line">run: gitlab-workhorse: (pid 17111) 276s; run: log: (pid 17010) 298s</div><div class="line">run: logrotate: (pid 17034) 294s; run: log: (pid 17033) 294s</div><div class="line">run: nginx: (pid 17019) 296s; run: log: (pid 17018) 296s</div><div class="line">run: postgresql: (pid 16863) 383s; run: log: (pid 16862) 383s</div><div class="line">run: redis: (pid 16776) 389s; run: log: (pid 16775) 389s</div><div class="line">run: sidekiq: (pid 17001) 300s; run: log: (pid 17000) 300s</div><div class="line">run: unicorn: (pid 16970) 302s; run: log: (pid 16969) 302s</div></pre></td></tr></table></figure></p>
<h2 id="访问-GitLab"><a href="#访问-GitLab" class="headerlink" title="访问 GitLab"></a>访问 GitLab</h2><p>访问 <code>http:gitlab_serverip</code>，即可访问 GitLab 的　Web 界面</p>
<ul>
<li>首次使用要设置密码</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;﻿Gitlab 是一个基于 &lt;code&gt;Ruby on Rails&lt;/code&gt; 开发的开源项目管理程序，可以通过 WEB 界面进行访问公开的或者私人项目，实现一个自托管的 Git 项目仓库。它拥有与 GitHub 类似的功能，可以浏览代码，管理缺陷和注释。&lt;/p&gt;
&lt;h2
    
    </summary>
    
      <category term="System" scheme="http://czero000.github.io/categories/System/"/>
    
      <category term="Gitlab" scheme="http://czero000.github.io/categories/System/Gitlab/"/>
    
    
      <category term="gitlab" scheme="http://czero000.github.io/tags/gitlab/"/>
    
  </entry>
  
  <entry>
    <title>使用gitolite管理git授权</title>
    <link href="http://czero000.github.io/2016/10/19/use-gitolite-manager-git.html"/>
    <id>http://czero000.github.io/2016/10/19/use-gitolite-manager-git.html</id>
    <published>2016-10-19T05:51:50.000Z</published>
    <updated>2016-10-19T09:19:25.337Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-gitolite-管理-git-服务器"><a href="#使用-gitolite-管理-git-服务器" class="headerlink" title="使用 gitolite 管理 git 服务器"></a>使用 gitolite 管理 git 服务器</h1><p>由于Git的设计初衷，在使用 Git 在面向团队服务时，如果需要对权限控制，就需要第三方的工具来帮助 Git。在 Git 管理工具中，有三个解决方案。</p>
<ul>
<li><a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="external">Gitosis</a> 轻量级、开源项目，使用 SSH 公钥认证，只能做到库级别的权限控制。现在项目已经停止开发，不在维护；</li>
<li><a href="https://github.com/sitaramc/gitolite" target="_blank" rel="external">Gitolite</a> 轻量级、开源项目，使用 SSH 公钥认证，可以做到对分支级的权限控制；</li>
<li>[<a href="http://git-scm.com/" target="_blank" rel="external">Git</a> + <a href="http://source.android.com/source/downloading.html" target="_blank" rel="external">Repo</a> + <a href="http://code.google.com/p/gerrit/" target="_blank" rel="external">Gerrit</a>] 重量级，集版本控制、库管理和代码审核。可以用来管理大型项目</li>
</ul>
<p>由于 gitosis 不在提供更新，新建项目使用 gitolite 配置 git 的访问控制。</p>
<h1 id="安装-Gitolite"><a href="#安装-Gitolite" class="headerlink" title="安装 Gitolite"></a>安装 Gitolite</h1><p>Gitolite 的安装步骤如下如：<br><img src="https://czero000.github.io/images/system/git/gitolite.png" alt="gitolite" title="Gitolite"></p>
<h2 id="系统环境"><a href="#系统环境" class="headerlink" title="系统环境"></a>系统环境</h2><p>系统采用最新的 <code>Ubuntu-16-04 LTS</code></p>
<table>
<thead>
<tr>
<th>角色</th>
<th>ip</th>
</tr>
</thead>
<tbody>
<tr>
<td>gitolite_gitServer</td>
<td>172.16.11.210</td>
</tr>
<tr>
<td>git_client</td>
<td>172.16.11.211</td>
</tr>
<tr>
<td>git_client</td>
<td>172.16.8.247</td>
</tr>
</tbody>
</table>
<h2 id="创建管理用户"><a href="#创建管理用户" class="headerlink" title="创建管理用户"></a>创建管理用户</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">adduser --system --shell /bin/bash --group --gecos &apos;Git SCM User&apos;--disabled-password --home /home/gitolite gitolite</div><div class="line">su - gitolite</div><div class="line">ssh-keygen -t rsa -q</div><div class="line">cp ~/.ssh/id_rsa.pub /tmp/gitolite.pub</div></pre></td></tr></table></figure>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// apt 安装</div><div class="line">sudo apt install git-core gitolite3</div><div class="line"></div><div class="line">// git clone</div><div class="line">git clone git://github.com/sitaramc/gitolite</div><div class="line">mkdir ~/bin</div><div class="line">gitolite/install  -ln ~/bin</div><div class="line">~/bin/gitolite setup -pk /tmp/gitolite.pub</div></pre></td></tr></table></figure>
<h2 id="配置授权"><a href="#配置授权" class="headerlink" title="配置授权"></a>配置授权</h2><h3 id="配置管理库"><a href="#配置管理库" class="headerlink" title="配置管理库"></a>配置管理库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// 执行命令之后，会在家目录中创建 `gitolite-admin` 的 git 仓库，可以通过修改这个仓库来管理 Gitolite</div><div class="line">git clone gitolite@172.16.11.210:gitolite-admin.git  </div><div class="line"></div><div class="line">// 配置 git</div><div class="line">git config --global push.default simple</div><div class="line">git config --global user.email &quot;charlie.cui127@gmail.com&quot;</div><div class="line">git config --global user.name &quot;Cc&quot;</div></pre></td></tr></table></figure>
<p>在 gitolite 仓库中有两个目录 <code>conf</code> 和 <code>keydir</code>,前者是配置权限的配置文件，后者是用来存放 Client 的 key/</p>
<h3 id="配置新用户"><a href="#配置新用户" class="headerlink" title="配置新用户"></a>配置新用户</h3><p>添加新用户很简单。添加一个名为 client1 的用户，获取她的公钥，命名为 client1.pub，然后放到在 <code>gitolite-admin</code>克隆的 keydir 目录。添加，提交，然后推送更改。这样用户就被添加了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -q</div><div class="line">scp id_rsa.pub 172.16.11.210:/tmp/client1.pub</div><div class="line">// ssh-key 都采用这样的命名方式 &lt;yourname&gt;.pub</div><div class="line">cp /tmp/client1.pub /home/gitolite/gitolite-admin/keydir/client1.pub</div></pre></td></tr></table></figure></p>
<h3 id="定制配置"><a href="#定制配置" class="headerlink" title="定制配置"></a>定制配置</h3><p><strong>官方示例</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cat conf/gitolite.conf</div><div class="line">repo gitolite-admin</div><div class="line">    RW+     =   gitolite</div><div class="line"></div><div class="line">repo testing</div><div class="line">    RW+     =   @all</div></pre></td></tr></table></figure>
<p><strong>用户管理可以给用户或者仓库分组 <code>@</code>代表组，成员之间空格分隔</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">@oss_repos = linux perl gitolite</div><div class="line">@admin     = Cc</div><div class="line">@devops    = alice bob charlie</div></pre></td></tr></table></figure>
<p><strong>权限分类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">C: 代表创建，仅用在通配符版本库授权时可以使用，用于指定那个用户可以创建和通配符匹配版本库</div><div class="line">R: 只读</div><div class="line">RW: 读写</div><div class="line">RW+: 除了读写权限，还可以对 rewind 的提交强制 push</div><div class="line">RWC、RW+C: 只有当授权指令中定义了正则引用（正则表达式定义的分支、里程碑等），才可以使用该授权指令。其中 C 的含义是允许创建和正则引用匹配的引用（分支或里程碑等）。</div><div class="line">RWD, RW+D: 只有当授权指令中定义了正则引用（正则表达式定义的分支、里程碑等），才可以使用该授权指令。其中 D 的含义是允许删除和正则引用匹配的引用（分支或里程碑等）。</div><div class="line">RWCD, RW+CD: 只有当授权指令中定义了正则引用（正则表达式定义的分支、里程碑等），才可以使用该授权指令。其中 C 的含义是允许创建和正则引用匹配的引用（分支或里程碑等），D 的含义是允许删除和正则引用匹配的引用（分支或里程碑等）。</div></pre></td></tr></table></figure></p>
<p><strong>拒绝访问</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">还有一种权限是 `-`表示拒绝， 拒绝</div><div class="line">RW  master integ    = @engineers</div><div class="line">-   master integ    = @engineers</div><div class="line">RW+                 = @engineers</div></pre></td></tr></table></figure></p>
<p><strong>限制文件</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">repo foo</div><div class="line">  RW    = @devops</div><div class="line">  - VERF/Makefile    = @devops</div></pre></td></tr></table></figure></p>
<h3 id="提交变更"><a href="#提交变更" class="headerlink" title="提交变更"></a>提交变更</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 使用 gitlite 用户</div><div class="line">git add .</div><div class="line">git commit -m &apos;xxx&apos;</div><div class="line">git push</div></pre></td></tr></table></figure>
<h3 id="新增项目"><a href="#新增项目" class="headerlink" title="新增项目"></a>新增项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">git init mytest</div><div class="line">cd mytest/</div><div class="line">echo &quot;is test.&quot; &gt; m.txt</div><div class="line">git add .</div><div class="line">git commit -am &apos;abc&apos;</div><div class="line">git remote add origin ssh://gitolite@localhost/mytest.git</div><div class="line">git push origin master</div><div class="line">git remote show origin</div><div class="line">git push --set-upstream origin master</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;使用-gitolite-管理-git-服务器&quot;&gt;&lt;a href=&quot;#使用-gitolite-管理-git-服务器&quot; class=&quot;headerlink&quot; title=&quot;使用 gitolite 管理 git 服务器&quot;&gt;&lt;/a&gt;使用 gitolite 管理 git 服
    
    </summary>
    
      <category term="System" scheme="http://czero000.github.io/categories/System/"/>
    
      <category term="Git" scheme="http://czero000.github.io/categories/System/Git/"/>
    
    
      <category term="git" scheme="http://czero000.github.io/tags/git/"/>
    
      <category term="gitolite" scheme="http://czero000.github.io/tags/gitolite/"/>
    
  </entry>
  
  <entry>
    <title>awk思维导图</title>
    <link href="http://czero000.github.io/2016/07/30/awk-mindmap.html"/>
    <id>http://czero000.github.io/2016/07/30/awk-mindmap.html</id>
    <published>2016-07-30T10:16:23.000Z</published>
    <updated>2016-10-19T02:15:36.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="awk-思维导图"><a href="#awk-思维导图" class="headerlink" title="awk 思维导图"></a>awk 思维导图</h1><p><img src="https://czero000.github.io/images/system/bash/awk_mind_map.png" alt="awk_mind_map"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;awk-思维导图&quot;&gt;&lt;a href=&quot;#awk-思维导图&quot; class=&quot;headerlink&quot; title=&quot;awk 思维导图&quot;&gt;&lt;/a&gt;awk 思维导图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://czero000.github.io/images/sy
    
    </summary>
    
      <category term="System" scheme="http://czero000.github.io/categories/System/"/>
    
      <category term="Bash" scheme="http://czero000.github.io/categories/System/Bash/"/>
    
    
      <category term="bash" scheme="http://czero000.github.io/tags/bash/"/>
    
      <category term="awk" scheme="http://czero000.github.io/tags/awk/"/>
    
      <category term="mindmap" scheme="http://czero000.github.io/tags/mindmap/"/>
    
  </entry>
  
  <entry>
    <title>Bash思维导图</title>
    <link href="http://czero000.github.io/2016/07/26/bash-mindmap.html"/>
    <id>http://czero000.github.io/2016/07/26/bash-mindmap.html</id>
    <published>2016-07-26T13:48:12.000Z</published>
    <updated>2016-10-19T02:15:36.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bash-思维导图"><a href="#Bash-思维导图" class="headerlink" title="Bash 思维导图"></a>Bash 思维导图</h1><p><img src="https://czero000.github.io/images/system/bash/bash_mind_map.png" alt="Bash Mind Map"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Bash-思维导图&quot;&gt;&lt;a href=&quot;#Bash-思维导图&quot; class=&quot;headerlink&quot; title=&quot;Bash 思维导图&quot;&gt;&lt;/a&gt;Bash 思维导图&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://czero000.github.io/image
    
    </summary>
    
      <category term="System" scheme="http://czero000.github.io/categories/System/"/>
    
      <category term="Bash" scheme="http://czero000.github.io/categories/System/Bash/"/>
    
    
      <category term="bash" scheme="http://czero000.github.io/tags/bash/"/>
    
      <category term="mindmap" scheme="http://czero000.github.io/tags/mindmap/"/>
    
  </entry>
  
  <entry>
    <title>使用zsh作为默认shell</title>
    <link href="http://czero000.github.io/2016/07/22/bash-change-to-zsh.html"/>
    <id>http://czero000.github.io/2016/07/22/bash-change-to-zsh.html</id>
    <published>2016-07-22T05:54:29.000Z</published>
    <updated>2016-10-19T02:20:53.583Z</updated>
    
    <content type="html"><![CDATA[<p>号称终极 Shell 的 Zsh 兼容 Bash，在命令补全方面有很好的体验，丰富的插件和主题可提供使用，配合 Oh-my-zsh 更加强大。</p>
<p>Linux 系统一般预装几种 Shell，系统默认的 Shell 是 Bash，安装前可以查看系统安装了哪些 Shell</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat /etc/shells</div></pre></td></tr></table></figure>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ul>
<li>Debian/Ubuntu</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install zsh</div></pre></td></tr></table></figure>
<ul>
<li>Redhat/CentOS </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">yum update</div><div class="line">yum install zsh</div></pre></td></tr></table></figure>
<p>安装完成后将 Zsh 替换 Bash 作为默认的 Shell，避免每次重启需要重新进入 Zsh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chsh -s /bin/zsh</div></pre></td></tr></table></figure>
<h1 id="安装-Oh-my-zsh"><a href="#安装-Oh-my-zsh" class="headerlink" title="安装 Oh-my-zsh"></a>安装 Oh-my-zsh</h1><p>需要使用到 Git，安装方法同上</p>
<p>下面通过自动安装的方式安装 Oh-my-zsh</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh -c &quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</div></pre></td></tr></table></figure>
<p>或者使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh</div><div class="line">cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc</div></pre></td></tr></table></figure>
<p>安装完成用户目录下会出现 .zshrc 文件，环境变量和别名都在这里定义，更改主题需要修改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ZSH_THEME=”robbyrussell”</div><div class="line">这里改为一个比较受欢迎的一款主题</div><div class="line">ZSH_THEME=&quot;agnoster&quot;</div></pre></td></tr></table></figure>
<p>oh my zsh 提供了数十种主题，相关文件在~/.oh-my-zsh/themes目录下，你可以随意选择，也可以编辑主题满足自己的变态需求，我采用了默认主题robbyrussell，但是做了一点小小的改动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">PROMPT=&apos;%&#123;$fg_bold[red]%&#125;➜ %&#123;$fg_bold[green]%&#125;%p%&#123;$fg[cyan]%&#125;%d %&#123;$fg_bold[blue]%&#125;$(git_prompt_info)%&#123;$fg_bold[blue]%&#125;% %&#123;$reset_color%&#125;&gt;&apos;</div><div class="line">#PROMPT=&apos;%&#123;$fg_bold[red]%&#125;➜ %&#123;$fg_bold[green]%&#125;%p %&#123;$fg[cyan]%&#125;%c %&#123;$fg_bold[blue]%&#125;$(git_prompt_info)%&#123;$fg_bold[blue]%&#125; % %&#123;$reset_color%&#125;&apos;</div></pre></td></tr></table></figure>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p>在这项配置项里添加需要的插件即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">plugins=(git bundler osx rake ruby)</div></pre></td></tr></table></figure></p>
<p> <strong> Zsh 的基本配置到这里结束，强大的 Zsh 还有更多功能可以发现。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;号称终极 Shell 的 Zsh 兼容 Bash，在命令补全方面有很好的体验，丰富的插件和主题可提供使用，配合 Oh-my-zsh 更加强大。&lt;/p&gt;
&lt;p&gt;Linux 系统一般预装几种 Shell，系统默认的 Shell 是 Bash，安装前可以查看系统安装了哪些 She
    
    </summary>
    
      <category term="System" scheme="http://czero000.github.io/categories/System/"/>
    
      <category term="Bash" scheme="http://czero000.github.io/categories/System/Bash/"/>
    
    
      <category term="zsh" scheme="http://czero000.github.io/tags/zsh/"/>
    
  </entry>
  
  <entry>
    <title>开源MySQL自动补全客户端</title>
    <link href="http://czero000.github.io/2016/05/31/autocompletion-of-opensource-mysqlclient.html"/>
    <id>http://czero000.github.io/2016/05/31/autocompletion-of-opensource-mysqlclient.html</id>
    <published>2016-05-31T07:19:48.000Z</published>
    <updated>2016-10-19T02:15:36.261Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>MyCli 是一个 MySQL 的命令行客户端，可以实现自动补全 <code>auto-completion</code> 和语法高亮，同时也可应用于 MariaDB 和 Percona。</p>
<p><strong>功能特征</strong></p>
<ul>
<li>MyCli 使用 <code>Python Prompt Toolkit</code> 编写。</li>
<li>支持语法高亮</li>
<li>当你输入 SQL 关键字，数据库的表格和列时可自动补全。</li>
<li>智能补全(默认启用)，会提示文本感应的 <code>context-sensitive</code> 补全。</li>
<li>配置文件在第一次启动时，自动创建在 <code>~/.myclirc</code></li>
</ul>
<p><strong>安装</strong></p>
<p>兼容性：<br>OS X 和 Linux 上测试过。运行在 <code>Python 2.6、2.7、3.3、3.4、3.5</code>。能够很好地处理 unicode 输入/输出。</p>
<ul>
<li><strong>Python Package</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ pip install myclior$ easy_install mycli</div></pre></td></tr></table></figure>
<ul>
<li><strong>Mac OS X</strong></li>
</ul>
<p>最简单的方法在 OS X 机器安装 mycli 是使用 homebrew</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ brew update &amp;&amp; brew install mycli</div></pre></td></tr></table></figure>
<ul>
<li><strong>Linux</strong></li>
</ul>
<p><strong>Debian/Ubuntu Package</strong><br>mycli托管在debian软件包<a href="packagecloud.io.">packagecloud.io.</a><br>添加gpg密钥packagecloud包验证。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ curl https://packagecloud.io/gpg.key | apt-key add -</div></pre></td></tr></table></figure>
<p>安装 apt-transport-https 包，支持 apt 使用 https 下载包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apt-get install -y apt-transport-https</div></pre></td></tr></table></figure>
<p>添加 mycli 安装源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ echo &quot;deb https://packagecloud.io/amjith/mycli/ubuntu/ trusty main&quot; | sudo tee -a /etc/apt/sources.list</div></pre></td></tr></table></figure>
<p>更新 mycli 的安装源，然后安装 mycli</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ sudo apt-get update</div><div class="line">$ sudo apt-get install mycli</div></pre></td></tr></table></figure>
<p>现在使用 <code>sudo apt-get upgrade mycli</code>很容易使 mycli 升级！</p>
<ul>
<li><strong>RHEL、Centos、Fedora</strong><br>我还没有为 mycli 构建 RPM 包。所以请使用 pip 安装 mycli。你可以在你的系统上安装 pip 使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo yum install python-pip python-devel</div></pre></td></tr></table></figure>
<p>一旦安装 pip ,您可以如下安装 mycli:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ sudo pip install mycli</div></pre></td></tr></table></figure>
<p><strong>效果图：</strong></p>
<ul>
<li>自动补全<br>简单的完成如关键字和sql函数。</li>
</ul>
<p><img src="https://czero000.github.io/images/database/mysql/auto-complite.png" alt=""></p>
<ul>
<li>智能提示<br>Table name completions after the ‘FROM’ keyword.</li>
</ul>
<p><img src="https://czero000.github.io/images/database/mysql/smart-completion.png" alt=""></p>
<ul>
<li>列名中引用的表的查询范围</li>
</ul>
<p><img src="https://czero000.github.io/images/database/mysql/columns.png" alt=""></p>
<ul>
<li>别名支持<br>列完成将即使工作表名称别名。</li>
</ul>
<p><img src="https://czero000.github.io/images/database/mysql/alias.png" alt=""></p>
<ul>
<li>语法高亮显示<br>sql 的语法高亮显示。</li>
</ul>
<p><img src="https://czero000.github.io/images/database/mysql/syntax.png" alt=""></p>
<ul>
<li>pager<br>一个 sql 命令的输出是通过更少的命令自动输送。</li>
</ul>
<p><img src="https://czero000.github.io/images/database/mysql/pager.png" alt=""></p>
<ul>
<li>动态效果图如下</li>
</ul>
<p><img src="https://czero000.github.io/images/database/mysql/main.gif" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;p&gt;MyCli 是一个 MySQL 的命令行客户端，可以实现自动补全 &lt;code&gt;auto-completion&lt;/code&gt; 和语法高亮，同时
    
    </summary>
    
      <category term="Database" scheme="http://czero000.github.io/categories/Database/"/>
    
      <category term="MySQL" scheme="http://czero000.github.io/categories/Database/MySQL/"/>
    
    
      <category term="mysql" scheme="http://czero000.github.io/tags/mysql/"/>
    
      <category term="mycli" scheme="http://czero000.github.io/tags/mycli/"/>
    
  </entry>
  
  <entry>
    <title>Python自动补全</title>
    <link href="http://czero000.github.io/2016/05/09/python-auto-completion.html"/>
    <id>http://czero000.github.io/2016/05/09/python-auto-completion.html</id>
    <published>2016-05-09T09:07:02.000Z</published>
    <updated>2016-10-19T09:18:53.361Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h2 id="Python-自动补全"><a href="#Python-自动补全" class="headerlink" title="Python 自动补全"></a>Python 自动补全</h2><p>下面是如何实现PythonTab补全和历史命令管理方法。</p>
<h3 id="Python的startup文件"><a href="#Python的startup文件" class="headerlink" title="Python的startup文件"></a>Python的startup文件</h3><p>为readline添加tab键自动补全功能，像shell一样管理历史命令</p>
<ul>
<li>获取python安装目录</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path</div><div class="line">[<span class="string">''</span>, <span class="string">'/usr/lib64/python27.zip'</span>, <span class="string">'/usr/lib64/python2.7'</span>, <span class="string">'/usr/lib64/python2.7/plat-linux2'</span>, <span class="string">'/usr/lib64/python2.7/lib-tk'</span>, <span class="string">'/usr/lib64/python2.7/lib-old'</span>, <span class="string">'/usr/lib64/python2.7/lib-dynload'</span>, <span class="string">'/usr/lib64/python2.7/site-packages'</span>, <span class="string">'/usr/lib64/python2.7/site-packages/gtk-2.0'</span>, <span class="string">'/usr/lib/python2.7/site-packages'</span>]</div></pre></td></tr></table></figure>
<p>安装目录为’/usr/lib64/python2.7’</p>
<ul>
<li>切换目录编写<code>startup.py</code>脚本,<code>cp startup.py /usr/lib64/python2.7/</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># python startup file</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> readline</div><div class="line"><span class="keyword">import</span> rlcompleter</div><div class="line"><span class="keyword">import</span> atexit</div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="comment"># tab completion</span></div><div class="line">readline.parse_and_bind(<span class="string">'tab: complete'</span>)</div><div class="line"><span class="comment"># history file</span></div><div class="line">histfile = os.path.join(os.environ[<span class="string">'HOME'</span>], <span class="string">'.pythonhistory'</span>)</div><div class="line"><span class="keyword">try</span>:</div><div class="line">    readline.read_history_file(histfile)</div><div class="line"><span class="keyword">except</span> IOError:</div><div class="line">    <span class="keyword">pass</span></div><div class="line">atexit.register(readline.write_history_file, histfile)</div><div class="line"><span class="keyword">del</span> os, histfile, readline, rlcompleter</div></pre></td></tr></table></figure>
<ul>
<li>增加环境变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">edit .bashrc</div><div class="line">// 增加下面内容</div><div class="line">export PYTHONSTARTUP=/usr/lib64/python2.7/startup.py</div><div class="line"></div><div class="line">// 变量生效</div><div class="line">source .bashrc</div></pre></td></tr></table></figure>
<h3 id="vim增加自动补全"><a href="#vim增加自动补全" class="headerlink" title="vim增加自动补全"></a>vim增加自动补全</h3><ul>
<li>下载插件</li>
</ul>
<p><a href="http://www.vim.org/scripts/script.php?script_id=850" target="_blank" rel="external">pydiction</a>:<a href="http://www.vim.org/scripts/script.php?script_id=850" target="_blank" rel="external">http://www.vim.org/scripts/script.php?script_id=850</a></p>
<ul>
<li>安装插件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">wget http://www.vim.org/scripts/download_script.php?src_id=21842</div><div class="line">unzip pydiction-1.2.3.zip</div><div class="line">cp pydiction/after/ftplugin/python_pydiction.vim /usr/share/vim/vim74/ftplugin/</div><div class="line">mkdir /usr/share/vim/vim74/pydiction</div><div class="line">cp pydiction/complete-dict /usr/share/vim/vim74/pydiction/</div><div class="line">cp pydiction/pydiction.py  /usr/share/vim/vim74/pydiction/</div></pre></td></tr></table></figure>
<ul>
<li>修改vim配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let g:pydiction_location = &apos;/usr/share/vim/vim74/pydiction/complete-dict&apos;</div><div class="line">let g:pydiction_menu_height = 20</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h2 id=&quot;Python-自动补全&quot;&gt;&lt;a href=&quot;#Python-自动补全&quot; class=&quot;headerlink&quot; title=&quot;Python 自动补全&quot;&gt;&lt;/a&gt;Python 自动补全&lt;/h2&gt;&lt;p&gt;下面是如何实现PythonTab
    
    </summary>
    
      <category term="Python" scheme="http://czero000.github.io/categories/Python/"/>
    
    
      <category term="python" scheme="http://czero000.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Git仓库搭建</title>
    <link href="http://czero000.github.io/2016/05/09/git-repo.html"/>
    <id>http://czero000.github.io/2016/05/09/git-repo.html</id>
    <published>2016-05-09T07:20:57.000Z</published>
    <updated>2016-10-19T02:15:36.273Z</updated>
    
    <content type="html"><![CDATA[<p>Github就是一个提供免费托管开源代码的远程仓库，但对于一些敏感代码或者不想开源的源代码，有不舍得付费，那么就需要自己搭建一台Git服务器作为私有仓库来使用。下面是搭建Git服务器过程。</p>
<h2 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h2><ul>
<li><p>安装git</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install git -y</div></pre></td></tr></table></figure>
</li>
<li><p>创建一个<code>git</code>用户，用来运行<code>git</code>服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useradd git</div></pre></td></tr></table></figure>
</li>
<li><p>创建证书登录<br>所有需要登录的用户，将他们自己的id_rsa.pub文件及公钥，导入到/home/git/.ssh/authorized_keys文件里，一行一个。</p>
</li>
<li><p>初始化git仓库<br>选当一个目录作为Git仓库，比如<code>/opt/GitWork</code>，在<code>/opt/GitWork</code>目录下创建git仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git init --bare  sample.git</div><div class="line">Initialized empty Git repository in /opt/GitWork/sample.git/</div></pre></td></tr></table></figure>
<p>Git会创建一个裸仓库，仓库没有工作区。</p>
</li>
<li><p>克隆远程仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git clone git@172.16.11.211:/opt/GitWork/sample.git</div><div class="line">Cloning into &apos;sample&apos;...</div><div class="line">warning: You appear to have cloned an empty repository.</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="公钥管理"><a href="#公钥管理" class="headerlink" title="公钥管理"></a>公钥管理</h2><p>  如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="external">Gitosis</a>来管理公钥。</p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="external">Gitolite</a>就是这个工具。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Github就是一个提供免费托管开源代码的远程仓库，但对于一些敏感代码或者不想开源的源代码，有不舍得付费，那么就需要自己搭建一台Git服务器作为私有仓库来使用。下面是搭建Git服务器过程。&lt;/p&gt;
&lt;h2 id=&quot;安装配置&quot;&gt;&lt;a href=&quot;#安装配置&quot; class=&quot;h
    
    </summary>
    
      <category term="System" scheme="http://czero000.github.io/categories/System/"/>
    
      <category term="Git" scheme="http://czero000.github.io/categories/System/Git/"/>
    
    
      <category term="git" scheme="http://czero000.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>MooseFS技术详解</title>
    <link href="http://czero000.github.io/2016/04/27/mfs-Technology.html"/>
    <id>http://czero000.github.io/2016/04/27/mfs-Technology.html</id>
    <published>2016-04-27T01:37:56.000Z</published>
    <updated>2016-10-19T02:15:36.297Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h1 id="MFS-概述"><a href="#MFS-概述" class="headerlink" title="MFS 概述"></a>MFS 概述</h1><p>MooseFS是一款具有冗余容错功能的分布式文件系统。它把数据分散在多台服务器上，确保一份数据多个备份副本，对外提供统一的结构。</p>
<h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><p>对于标准的文件操作，MooseFS表现与其他类Unix文件系统一致。<br>支持的通过文件系统特性：</p>
<ul>
<li>层次结构（目录树）</li>
<li>兼容POSIX文件属性</li>
<li>支持特殊文件</li>
<li>符号链接和硬链接</li>
<li>基于IP地址和密码的访问控制</li>
</ul>
<h2 id="独有特性"><a href="#独有特性" class="headerlink" title="独有特性"></a>独有特性</h2><ul>
<li>高可靠性(数据的多个副本存储在不同服务器)</li>
<li>容量动态扩展（添加新硬盘或者服务器）</li>
<li>可以回收在制定时间内删除的文件，类似回收站功能</li>
<li>可以对整个文件甚至是正在被写入的文件创建文件快照</li>
</ul>
<h2 id="MFS整体架构的四种角色"><a href="#MFS整体架构的四种角色" class="headerlink" title="MFS整体架构的四种角色"></a>MFS整体架构的四种角色</h2><ul>
<li><p>Master（元数据服务器）<br>负责各个数据存储服务器的管理，文件读写调度，文件空间回收以及恢复，多节点拷贝。</p>
</li>
<li><p>Metalogger（元数据日志服务器）<br>负责备份Master服务器的changelog。文件类型为<code>changelog.*.mfs</code>，以便在Master出问题时接替其工作</p>
</li>
<li><p>Chunk（数据存储服务器）<br>负责连接Master，听从Master调度，提供存储空间，并为客户端提供数据传输</p>
</li>
<li><p>Client（客户端挂载）<br>通过FUSE内核接口挂载远程管理服务器（master）上所管理的数据存储服务器，使用起来和本地文件系统一样</p>
</li>
</ul>
<h2 id="MFS工作图解"><a href="#MFS工作图解" class="headerlink" title="MFS工作图解"></a>MFS工作图解</h2><ul>
<li>网络架构</li>
</ul>
<p><img src="https://czero000.github.io/images/opstech/moosefs/moosefs-network.png" alt="MooseFS-NetWork.png" title="MooseFS-NetWork"></p>
<ul>
<li>工作原理</li>
</ul>
<p><img src="https://czero000.github.io/images/opstech/moosefs/moosefs-write-process.png" alt="moosefs-write-process.png" title="MooseFS Write Process"></p>
<p><img src="https://czero000.github.io/images/opstech/moosefs/moosefs-read-process.png" alt="moosefs-read-process.png" title="MooseFS Read Process"></p>
<ul>
<li>集群拓扑</li>
</ul>
<p><img src="https://czero000.github.io/images/opstech/moosefs/mfs-topology.png" alt="mfs-topology.png" title="MooseFS-Topology"></p>
<hr>
<h1 id="安装配置MFS"><a href="#安装配置MFS" class="headerlink" title="安装配置MFS"></a>安装配置MFS</h1><h2 id="系统环境介绍"><a href="#系统环境介绍" class="headerlink" title="系统环境介绍"></a>系统环境介绍</h2><ul>
<li>OS：<code>CentOS Linux release 7.2.1511 (Core)</code></li>
<li>软件版本：2.0.81-1</li>
<li>节点配置</li>
</ul>
<table>
<thead>
<tr>
<th>ip地址</th>
<th>角色</th>
</tr>
</thead>
<tbody>
<tr>
<td>172.16.18.137</td>
<td>master</td>
</tr>
<tr>
<td>172.16.18.134</td>
<td>metalogger</td>
</tr>
<tr>
<td>172.16.18.183</td>
<td>chunk</td>
</tr>
<tr>
<td>172.16.18.184</td>
<td>chunk</td>
</tr>
<tr>
<td>172.16.18.185</td>
<td>chunk</td>
</tr>
<tr>
<td>172.16.18.186</td>
<td>chunk</td>
</tr>
<tr>
<td>172.16.18.187</td>
<td>chunk</td>
</tr>
</tbody>
</table>
<p>chunk上有四块硬盘，第一块为系统，剩下三块作为数据存储，每块容量为4TB</p>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><h3 id="从官方软件库安装MFS"><a href="#从官方软件库安装MFS" class="headerlink" title="从官方软件库安装MFS"></a>从官方软件库安装MFS</h3><ul>
<li>添加yum key</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl &quot;http://ppa.moosefs.com/RPM-GPG-KEY-MooseFS&quot; &gt; /etc/pki/rpm-gpg/RPM-GPG-KEY-MooseFS</div></pre></td></tr></table></figure>
<ul>
<li>下载软件库配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">//For EL7 family:</div><div class="line">curl &quot;http://ppa.moosefs.com/MooseFS-stable-el7.repo&quot; &gt; /etc/yum.repos.d/MooseFS.repo</div><div class="line"></div><div class="line">//For EL6 family:</div><div class="line">curl &quot;http://ppa.moosefs.com/MooseFS-stable-el6.repo&quot; &gt; /etc/yum.repos.d/MooseFS.repo</div><div class="line"></div><div class="line">For EL5 family:</div><div class="line">Due to GPGv4 incompatibility with CentOS 5, CentOS 5 is deprecated.</div><div class="line">If you really need CentOS 5 packages, please contact support@moosefs.com.</div></pre></td></tr></table></figure>
<ul>
<li>安装软件包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// For Master Server:</div><div class="line">yum install moosefs-master moosefs-cli moosefs-cgi moosefs-cgiserv</div><div class="line"></div><div class="line">// For Chunkservers:</div><div class="line">yum install moosefs-chunkserver</div><div class="line"></div><div class="line">//For Metaloggers:</div><div class="line">yum install moosefs-metalogger</div><div class="line"></div><div class="line">For Clients:</div><div class="line">//yum install moosefs-client</div></pre></td></tr></table></figure>
<ul>
<li>启动服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//To start process manually:</div><div class="line">mfsmaster start</div><div class="line">mfschunkserver start</div><div class="line"></div><div class="line">//For systemd OS family - EL7:</div><div class="line">systemctl start moosefs-master.service</div><div class="line">systemctl start moosefs-chunkserver.service</div><div class="line"></div><div class="line">//For SysV OS family - EL6:</div><div class="line">service moosefs-master start </div><div class="line">service moosefs-chunkserver start</div></pre></td></tr></table></figure>
<hr>
<h3 id="从源码安装MFS"><a href="#从源码安装MFS" class="headerlink" title="从源码安装MFS"></a>从源码安装MFS</h3><ul>
<li>下载软件包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://ppa.moosefs.com/src/moosefs-2.0.88-1.tar.gz</div></pre></td></tr></table></figure>
<ul>
<li>添加用户和组</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">useradd -s /sbin/nologin  -M mfs</div></pre></td></tr></table></figure>
<ul>
<li>安装软件包</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">tar-zxf moosefs-2.0.88-1.tar.gz</div><div class="line">cd moosefs-2.0.88</div><div class="line"></div><div class="line">// For master</div><div class="line">./configure --prefix=/usr/local/mfs --with-default-user=mfs --with-default-group=mfs --disable-mfschunkserver --disable-mfsmount</div><div class="line"></div><div class="line">// For metalogger</div><div class="line">./configure --prefix=/usr/local/mfs --with-default-user=mfs --with-default-group=mfs --disable-mfschunkserver --disable-mfsmount </div><div class="line"></div><div class="line">// For chunk</div><div class="line">./configure --prefix=/usr/local/mfs --with-default-user=mfs --with-default-group=mfs --disable-mfsmaster --disable-mfsmount --disable-mfscgi --disable-mfscgiserv</div></pre></td></tr></table></figure>
<ul>
<li>安装MFS client</li>
</ul>
<p>client安装需要fuse支持，fuse可以从源码和仓库中安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./configure --prefix=/usr/local/mfs --with-default-user=mfs --with-default-group=mfs --disable-mfsmaster --disable-mfschunkserver --disable-mfscgi --disable-mfscgiserv</div></pre></td></tr></table></figure>
<h2 id="配置MFS"><a href="#配置MFS" class="headerlink" title="配置MFS"></a>配置MFS</h2><h3 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h3><ul>
<li>配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">// mfsmaster.cfg</div><div class="line"># WORKING_USER = mfs 运行 master server 的用户</div><div class="line"># WORKING_GROUP = mfs 运行 master server 的组</div><div class="line"># SYSLOG_IDENT = mfsmaster master server 在 syslog中的标识，说明是由 master serve 产生的</div><div class="line"># LOCK_MEMORY = 0 是否执行 mlockall()以避免 mfsmaster 进程溢出（默认为 0）</div><div class="line"># NICE_LEVEL = -19 运行的优先级(如果可以默认是 -19; 注意: 进程必须是用 root启动)</div><div class="line"></div><div class="line"># EXPORTS_FILENAME = /usr/local/mfs/etc/mfsexports.cfg 被挂接目录及其权限控制文件的存放位置</div><div class="line"></div><div class="line"># TOPOLOGY_FILENAME = /usr/local/mfs/etc/mfs/mfstopology.cfg</div><div class="line"></div><div class="line"># DATA_PATH = /usr/local/mfs/var/mfs 数据存放路径，此目录下大致有三类文件，changelog，sessions和 stats；</div><div class="line"></div><div class="line"># BACK_LOGS = 50 metadata 的改变 log 文件数目(默认是 50);</div><div class="line"># BACK_META_KEEP_PREVIOUS = 1</div><div class="line"></div><div class="line"># REPLICATIONS_DELAY_INIT = 300 延迟复制的时间（默认是 300s）;</div><div class="line"># REPLICATIONS_DELAY_DISCONNECT = 3600 chunkserver 断开的复制延迟（默认是 3600）；</div><div class="line"></div><div class="line"># MATOML_LISTEN_HOST = * metalogger 监听的 IP 地址(默认是*，代表任何 IP)；</div><div class="line"># MATOML_LISTEN_PORT = 9419 metalogger 监听的端口地址(默认是 9419)；</div><div class="line"># MATOML_LOG_PRESERVE_SECONDS = 600</div><div class="line"></div><div class="line"># MATOCS_LISTEN_HOST = * 用于 chunkserver 连接的 IP 地址（默认是*，代表任何 IP）；</div><div class="line"># MATOCS_LISTEN_PORT = 9420 用于 chunkserver 连接的端口地址（默认是 9420）；</div><div class="line"></div><div class="line"># MATOCU_LISTEN_HOST = * 用于客户端挂接连接的 IP 地址(默认是*，代表任何 IP)；</div><div class="line"># MATOCU_LISTEN_PORT = 9421 用于客户端挂接连接的端口地址（默认是 9421）；</div><div class="line"></div><div class="line"># CHUNKS_LOOP_MAX_CPS = 100000</div><div class="line"># CHUNKS_LOOP_MIN_TIME = 300 chunks 的回环频率（默认是：300 秒）；</div><div class="line">注：原文为Chunks loop frequency in seconds (default is 300)</div><div class="line"></div><div class="line"># CHUNKS_SOFT_DEL_LIMIT = 10</div><div class="line"># CHUNKS_HARD_DEL_LIMIT = 25</div><div class="line"># CHUNKS_WRITE_REP_LIMIT = 2</div><div class="line"># CHUNKS_READ_REP_LIMIT = 10</div><div class="line"># ACCEPTABLE_DIFFERENCE = 0.1</div><div class="line"></div><div class="line"># SESSION_SUSTAIN_TIME = 86400</div><div class="line"># REJECT_OLD_CLIENTS = 0 弹出低于 1.6.0 的客户端挂接（0 或 1，默认是 0）注意mfsexports 访问控制对于那些老客户是没用的</div><div class="line"># deprecated:</div><div class="line"># CHUNKS_DEL_LIMIT - use CHUNKS_SOFT_DEL_LIMIT instead</div><div class="line"># LOCK_FILE - lock system has been changed, and this option is used only to search for old lockfile</div><div class="line"></div><div class="line"></div><div class="line">\\ mfsexport.cfg</div><div class="line">#* / ro</div><div class="line">#192.168.1.0/24 / rw</div><div class="line">#192.168.1.0/24 / rw,alldirs,maproot=0,password=passcode</div><div class="line">#10.0.0.0-10.0.0.5 /test rw,maproot=nobody,password=test</div><div class="line">* . rw</div><div class="line">#* / rw,alldirs,maproot=0</div><div class="line">172.16.18.221          .               rw                             \\ 回收站</div><div class="line">172.16.18.221          /               rw,alldirs,maproot=0</div><div class="line">172.16.18.134          /               rw,alldirs,maproot=0</div></pre></td></tr></table></figure>
<ul>
<li>修改配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/mfs/etc/</div><div class="line">mv mfsmaster.cfg.dist mfsmaster.cfg</div><div class="line">mv mfsexports.cfg.dist mfsexports.cfg</div></pre></td></tr></table></figure>
<p>mfsmaster.cfg : master的主配置文件，配置文件中所有的选项都是用#注释掉的，这代表的是将会使用的选项的默认参数，如果要修改只需取消注释修改其值为你所要使用的值即可；</p>
<p>mfsexportes.cfg 为共享mfs文件系统的控制文件，NFS要共享一个目录时，我们会使用vim /etc/exports命令，编写共享给谁，所要共享的目录，共享出去的属性这些内容，而mfsexports.cfg的作用与其类似其书写格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">client		Directory			Property</div><div class="line">*                /       	rw,alldirs,maproot=0</div><div class="line">client支持格式：ip、ip/netmask、ip/位数掩码、ip-ip、*</div></pre></td></tr></table></figure>
<p>该文件每一个条目分为三部分：<br>第一部分：客户端的ip 地址<br>第二部分：被挂接的目录<br>第三部分：客户端拥有的权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">//地址可以指定的几种表现形式：</div><div class="line">* 所有的ip 地址</div><div class="line">n.n.n.n 单个ip 地址</div><div class="line">n.n.n.n/b IP 网络地址/位数掩码</div><div class="line">n.n.n.n/m.m.m.m IP 网络地址/子网掩码</div><div class="line">f.f.f.f-t.t.t.t IP 段</div><div class="line"></div><div class="line">//目录部分需要注意两点：</div><div class="line">/ 标识MooseFS 根;</div><div class="line">. 表示MFSMETA 文件系统</div><div class="line"></div><div class="line">//权限部分：</div><div class="line">ro 只读模式共享</div><div class="line">rw 读写的方式共享</div><div class="line">alldirs 许挂载任何指定的子目录</div></pre></td></tr></table></figure></p>
<ul>
<li>启动服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/usr/local/mfs/sbin/mfsmaster start</div><div class="line"></div><div class="line">//为了监控moosefs的当前运行状态，我们可以运行cgi服务，这样就可以用浏览器查看整个moosefs的运行情况</div><div class="line">/usr/local/mfs/sbin/mfscgiserv</div></pre></td></tr></table></figure>
<h3 id="Metalogger"><a href="#Metalogger" class="headerlink" title="Metalogger"></a>Metalogger</h3><ul>
<li>修改配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mv mfsmetalogger.cfg.dist mfsmetalogger.cfg</div><div class="line"></div><div class="line">META_DOWNLOAD_FREQ = 24 \\元数据备份下载请求频率，设置为1小时</div><div class="line">MASTER_HOST = 172.16.18.137 \\修改MASTER_HOST的值，为MASTER_HOST的ip地址</div></pre></td></tr></table></figure>
<ul>
<li>启动服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/mfs/sbin/mfsmetalogger start</div></pre></td></tr></table></figure>
<h3 id="ChunkServer"><a href="#ChunkServer" class="headerlink" title="ChunkServer"></a>ChunkServer</h3><ul>
<li>配置分区</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">parted -s /dev/sdb &apos;mklabel gpt&apos;;parted -s /dev/sdc &apos;mklabel gpt&apos;;parted -s /dev/sdd &apos;mklabel gpt&apos;</div><div class="line">parted -s /dev/sdb  &apos;mkpart primary 0 -1&apos;; parted -s /dev/sdc  &apos;mkpart primary 0 -1&apos;; parted -s /dev/sdd &apos;mkpart primary 0 -1&apos;</div><div class="line">mkfs.ext4 -q -T largefile /dev/sdb1;mkfs.ext4 -q -T largefile /dev/sdc1;mkfs.ext4 -q -T largefile /dev/sdd1</div><div class="line">mkdir /MFS_data&#123;1,2,3&#125;  </div><div class="line">mount /dev/sdb1 /MFS_data1; mount /dev/sdc1 /MFS_data2; mount /dev/sdd1 /MFS_data3</div><div class="line">chown mfs:mfs /MFS_data*</div></pre></td></tr></table></figure>
<ul>
<li>修改配置文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">mv mfschunkserver.cfg.dist mfschunkserver.cfg</div><div class="line">修改MASTER_HOST的值，为MASTER_HOST的ip地址：</div><div class="line">MASTER_HOST = 172.16.18.137</div><div class="line"></div><div class="line">mv mfshdd.cfg.dist mfshdd.cfg</div><div class="line">增加挂载目录信息</div><div class="line">/MFS_data1</div><div class="line">/MFS_data2</div><div class="line">/MFS_data3</div></pre></td></tr></table></figure>
<ul>
<li>启动服务</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/mfs/sbin/mfschunkserver start</div></pre></td></tr></table></figure>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><ul>
<li>挂载MFS</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir /MFS_data</div><div class="line">/usr/local/mfs/bin/mfsmount /MFS_data -H 172.16.18.137</div><div class="line">mfsmaster accepted connection with parameters: read-write,restricted_ip ; root mapped to root:root</div></pre></td></tr></table></figure>
<p>特别需要注意的是，所有的MFS 都是挂接同一个元数据服务器master 的IP,而不是其他数据存储<br>服务器chunkserver 的IP</p>
<hr>
<h1 id="使用MFS"><a href="#使用MFS" class="headerlink" title="使用MFS"></a>使用MFS</h1><h2 id="MFS文件系统使用"><a href="#MFS文件系统使用" class="headerlink" title="MFS文件系统使用"></a>MFS文件系统使用</h2><p>Client通过MFS软件提供的工具来管理MFS文件系统，下面是工具介绍</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/usr/local/mfs/bin/mfstools -h</div><div class="line">mfs multi tool</div><div class="line"></div><div class="line">usage:</div><div class="line">        mfstools create - create symlinks (mfs&lt;toolname&gt; -&gt; /usr/local/mfs/bin/mfstools)</div><div class="line"></div><div class="line">tools:</div><div class="line">        mfsgetgoal                               // 设定副本数</div><div class="line">        mfssetgoal                               // 获取副本数</div><div class="line">        mfsgettrashtime                          // 设定回收站时间</div><div class="line">        mfssettrashtime                          // 设定回收站时间</div><div class="line">        mfscheckfile                             // 检查文件</div><div class="line">        mfsfileinfo                              // 文件信息</div><div class="line">        mfsappendchunks                            </div><div class="line">        mfsdirinfo                                // 目录信息</div><div class="line">        mfsfilerepair                             // 文件修复</div><div class="line">        mfsmakesnapshot                           // 快照     </div><div class="line">        mfsgeteattr                               // 设置权限</div><div class="line">        mfsseteattr</div><div class="line">        mfsdeleattr</div><div class="line"></div><div class="line">deprecated tools:                                  // 递归设置</div><div class="line">        mfsrgetgoal = mfsgetgoal -r</div><div class="line">        mfsrsetgoal = mfssetgoal -r</div><div class="line">        mfsrgettrashtime = mfsgettreshtime -r</div><div class="line">        mfsrsettrashtime = mfssettreshtime -r</div></pre></td></tr></table></figure>
<h3 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h3><p>MooseFS 文件系统利用下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">mfsmount mountpoint [-d][-f] [-s][-m] [-n][-p] [-HMASTER][-PPORT] [-S PATH][-o OPT[,OPT...]]</div><div class="line">-H MASTER：是管理服务器（master server）的ip 地址</div><div class="line">-P PORT： 是管理服务器（ master server）的端口号，要按照mfsmaster.cfg 配置文件中的变量</div><div class="line">MATOCU_LISTEN_POR 的之填写。如果master serve 使用的是默认端口号则不用指出。</div><div class="line">-S PATH：指出被挂接mfs 目录的子目录，默认是/目录，就是挂载整个mfs 目录。</div></pre></td></tr></table></figure>
<p>Mountpoint：是指先前创建的用来挂接mfs 的目录。<br>在开始mfsmount 进程时，用一个-m 或-o mfsmeta 的选项，这样可以挂接一个辅助的文件系统<br>MFSMETA，这么做的目的是对于意外的从MooseFS 卷上删除文件或者是为了释放磁盘空间而移动的<br>文件而又此文件又过去了垃圾文件存放期的恢复，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/mfs/bin/mfsmount -m /MFS_meta/ -H 172.16.18.137</div></pre></td></tr></table></figure>
<h3 id="设定副本数量"><a href="#设定副本数量" class="headerlink" title="设定副本数量"></a>设定副本数量</h3><p>目标（goal），是指文件被拷贝副本的份数，设定了拷贝的份数后是可以通过mfsgetgoal 命令来证实的，也可以通过mfsrsetgoal 来改变设定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mfssetgoal 3 /MFS_data/test/ </div><div class="line">mfssetgoal 3 /MFS_data/test/</div></pre></td></tr></table></figure>
<p>用<code>mfsgetgoal –r</code> 和<code>mfssetgoal –r</code> 同样的操作可以对整个树形目录递归操作，其等效于<code>mfsrsetgoal</code>命令。实际的拷贝份数可以通过<code>mfscheckfile</code> 和<code>mfsfile info</code>命令来证实。</p>
<p><strong>注意以下几种特殊情况：</strong></p>
<ul>
<li>一个不包含数据的零长度的文件,尽管没有设置为非零的目标（the non-zero “goal”）,但用mfscheckfile 命令查询将返回一个空的结果；将文件填充内容后，其会根据设置的goal创建副本；这时再将文件清空，其副本依然作为空文件存在。</li>
<li>假如改变一个已经存在的文件的拷贝个数，那么文件的拷贝份数将会被扩大或者被删除，这个过程会有延时。可以通过mfscheckfile 命令来证实。</li>
<li>对一个目录设定“目标”，此目录下的新创建文件和子目录均会继承此目录的设定，但不会改变已经存在的文件及目录的拷贝份数。</li>
</ul>
<p>可以通过mfsdirinfo来查看整个目录树的信息摘要。</p>
<h3 id="垃圾回收站"><a href="#垃圾回收站" class="headerlink" title="垃圾回收站"></a>垃圾回收站</h3><p>一个被删除文件能够存放在一个“ 垃圾箱”的时间就是一个隔离时间， 这个时间可以用<code>mfsgettrashtime</code> 命令来验证，也可以使用`mfssettrashtime 命令来设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mfssettrashtime 64800 /MFS_data/test/test1 </div><div class="line">mfsgettrashtime /MFS_data/test/test1</div></pre></td></tr></table></figure></p>
<p>时间的单位是秒(有用的值有:1 小时是3600 秒,24 - 86400 秒,1天 - 604800 秒)。就像文件被存储的份数一样, 为一个目录设定存放时间是要被新创建的文件和目录所继承的。数字0 意味着一个文件被删除后, 将立即被彻底删除，在想回收是不可能的。</p>
<p>删除文件可以通过一个单独安装MFSMETA 文件系统。特别是它包含目录/ trash (包含任然可以被还原的被删除文件的信息)和/ trash/undel (用于获取文件)。只有管理员有权限访问MFSMETA(用户的uid 0，通常是root)。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/local/mfs/bin/mfsmount -m /MFS_meta/ -H 172.16.18.137</div></pre></td></tr></table></figure>
<p>被删文件的文件名在“垃圾箱”目录里还可见,文件名由一个八位十六进制的数i-node 和被删文件的文件名组成，在文件名和i-node 之间不是用“/”,而是用了“|”替代。如果一个文件名的长度超过操作系统的限制（通常是255 个字符），那么部分将被删除。通过从挂载点起全路径的文件名被删除的文件任然可以被读写。</p>
<p>移动这个文件到trash/undel 子目录下，将会使原始的文件恢复到正确的MooseFS 文件系统上路径下（如果路径没有改变）。如果在同一路径下有个新的同名文件，那么恢复不会成功。</p>
<p>从“垃圾箱”中删除文件结果是释放之前被它站用的空间(删除有延迟,数据被异步删除)。</p>
<p>在MFSMETA中还有另一个目录reserved，该目录内的是被删除但依然打开的文件。在用户关闭了这些被打开的文件后，reserved 目录中的文件将被删除，文件的数据也将被立即删除。在reserved 目录中文件的命名方法同trash 目录中的一样，但是不能有其他功能的操作。</p>
<h3 id="快照snapshot"><a href="#快照snapshot" class="headerlink" title="快照snapshot"></a>快照snapshot</h3><p>MooseFS 系统的另一个特征是利用mfsmakesnapshot 工具给文件或者是目录树做快照<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mfsmakesnapshot source ... destination</div></pre></td></tr></table></figure></p>
<p>Mfsmakesnapshot 是在一次执行中整合了一个或是一组文件的拷贝，而且任何修改这些文件的源文件都不会影响到源文件的快照， 就是说任何对源文件的操作,例如写入源文件，将不会修改副本(或反之亦然)。<br>也可以使用mfsappendchunks：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mfsappendchunks destination-file source-file ...</div></pre></td></tr></table></figure></p>
<p>当有多个源文件时，它们的快照被加入到同一个目标文件中（每个chunk 的最大量是chunk）。</p>
<h2 id="MFS集群维护"><a href="#MFS集群维护" class="headerlink" title="MFS集群维护"></a>MFS集群维护</h2><h3 id="启动MFS集群"><a href="#启动MFS集群" class="headerlink" title="启动MFS集群"></a>启动MFS集群</h3><p>安全的启动MooseFS 集群（避免任何读或写的错误数据或类似的问题）的方式是按照以下命令步骤：</p>
<ol>
<li>启动mfsmaster 进程</li>
<li>启动所有的mfschunkserver 进程</li>
<li>启动mfsmetalogger 进程（如果配置了mfsmetalogger）</li>
<li>当所有的chunkservers 连接到MooseFS master 后，任何数目的客户端可以利用mfsmount 去挂接被export 的文件系统。（可以通过检查master 的日志或是CGI 监视器来查看是否所有的chunkserver被连接）。</li>
</ol>
<h3 id="停止MFS集群"><a href="#停止MFS集群" class="headerlink" title="停止MFS集群"></a>停止MFS集群</h3><p>安全的停止MooseFS 集群：</p>
<ol>
<li>在所有的客户端卸载MooseFS 文件系统（用umount 命令或者是其它等效的命令）</li>
<li>用mfschunkserver stop 命令停止chunkserver 进程</li>
<li>用mfsmetalogger stop 命令停止metalogger 进程</li>
<li>用mfsmaster stop 命令停止master 进程</li>
</ol>
<h3 id="Chunkservers-的维护"><a href="#Chunkservers-的维护" class="headerlink" title="Chunkservers 的维护"></a>Chunkservers 的维护</h3><p>若每个文件的goal（目标）都不小于2，并且没有under-goal 文件（这些可以用mfsgetgoal –r和mfsdirinfo 命令来检查），那么一个单一的chunkserver 在任何时刻都可能做停止或者是重新启动。以后每当需要做停止或者是重新启动另一个chunkserver 的时候，要确定之前的chunkserver 被连接，而且要没有under-goal chunks。</p>
<h3 id="MFS元数据备份"><a href="#MFS元数据备份" class="headerlink" title="MFS元数据备份"></a>MFS元数据备份</h3><p>通常元数据有两部分的数据：</p>
<ul>
<li>主要元数据文件metadata.mfs，当mfsmaster 运行的时候会被命名为metadata.mfs.back</li>
<li>元数据改变日志changelog.*.mfs，存储了过去的N 小时的文件改变（N 的数值是由BACK_LOGS参数设置的，参数的设置在mfschunkserver.cfg 配置文件中）。</li>
</ul>
<p>主要的元数据文件需要定期备份，备份的频率取决于取决于多少小时changelogs 储存。元数据changelogs 实时的自动复制。1.6版本中这个工作都由metalogger完成。</p>
<h3 id="MFS-Master的恢复"><a href="#MFS-Master的恢复" class="headerlink" title="MFS Master的恢复"></a>MFS Master的恢复</h3><p>一旦mfsmaster 崩溃（例如因为主机或电源失败），需要最后一个元数据日志changelog 并入主要的metadata 中。这个操作时通过<code>mfsmetarestore</code>工具做的，最简单的方法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mfsmetarestore -a</div></pre></td></tr></table></figure>
<p>如果master 数据被存储在MooseFS 编译指定地点外的路径，则要利用-d 参数指定使用，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mfsmetarestore -a -d /opt/mfsmaster</div></pre></td></tr></table></figure>
<h3 id="从MetaLogger中恢复Master"><a href="#从MetaLogger中恢复Master" class="headerlink" title="从MetaLogger中恢复Master"></a>从MetaLogger中恢复Master</h3><p>如果mfsmetarestore -a无法修复，则使用metalogger也可能无法修复，暂时没遇到过这种情况，这里不暂不考虑。</p>
<ol>
<li>找回metadata.mfs.back 文件，可以从备份中找，也可以中metalogger 主机中找（如果启动了metalogger 服务），然后把metadata.mfs.back 放入data 目录，一般为{prefix}/var/mfs</li>
<li>从在master 宕掉之前的任何运行metalogger 服务的服务器上拷贝最后metadata 文件，然后放入mfsmaster 的数据目录。</li>
<li>利用mfsmetarestore 命令合并元数据changelogs，可以用自动恢复模式mfsmetarestore –a，也可以利用非自动化恢复模式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mfsmetarestore -m metadata.mfs.back -o metadata.mfs changelog_ml.*.mfs</div></pre></td></tr></table></figure>
<p>或：强制使用metadata.mfs.back创建metadata.mfs，可以启动master，但丢失的数据暂无法确定。</p>
<h3 id="Automated-Failover"><a href="#Automated-Failover" class="headerlink" title="Automated Failover"></a>Automated Failover</h3><p>生产环境使用 MooseFS 时，需要保证 master 节点的高可用。 使用 <code>ucarp</code> 是一种比较成熟的方案，或者<code>DRBD+[hearbeat|keepalived]</code>。<code>ucarp</code> 类似于 <code>keepalived</code>，通过主备服务器间的健康检查来发现集群状态，并执行相应操作。另外 MooseFS商业版本已经支持双主配置，解决单点故障。</p>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;MFS-概述&quot;&gt;&lt;a href=&quot;#MFS-概述&quot; class=&quot;headerlink&quot; title=&quot;MFS 概述&quot;&gt;&lt;/a&gt;MFS 概述&lt;/h1&gt;&lt;p&gt;MooseFS是一款具有冗余容错功能的分布式文件系统。它把数据分散在多台
    
    </summary>
    
      <category term="运维技术" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/"/>
    
      <category term="MooseFS" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E6%8A%80%E6%9C%AF/MooseFS/"/>
    
    
      <category term="MooseFS" scheme="http://czero000.github.io/tags/MooseFS/"/>
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://czero000.github.io/2016/04/18/git-common.html"/>
    <id>http://czero000.github.io/2016/04/18/git-common.html</id>
    <published>2016-04-18T06:19:55.000Z</published>
    <updated>2016-10-19T02:15:36.273Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<p>Git已经成为程序员日常工具之一，那些Git基本的命令，每天都要用的命令你都记住了吗？如果还没的话，笔者整理了一份清单，以备不时之需所用。</p>
<ul>
<li><p>三个基本概念</p>
</li>
<li><p>工作区(Workspace)是计算机中项目的根目录</p>
</li>
<li>暂存区(Index)像个缓存区域，临时保存你的改动</li>
<li>版本库(Repository)分为本地仓库（Local)和远程仓库(Remote)<br>几乎所有常用命令就是围绕这几个概念来操作的，一图胜千言，下面是一张比较简单的图，包括了最基本的命令</li>
</ul>
<p><img src="https://czero000.github.io/images/system/git/git-simple.png" alt="simple"></p>
<p>但只会使用以上命令是不够的，在这个复杂纷繁的程序世界，事情没你想的那么简单，不过有些事情想想就够了，不一定要去做，真要去做你也做不来，比如自己写个git来，但是，更多地的了解git是我们每个程序员都可以做得到的事。再看下图：<br> <img src="https://czero000.github.io/images/system/git/git-advance.jpg" alt="git-advance"></p>
<p>下面的命令结合上面两张图来理解、练习、记忆效果更加。暂时用不着的命令记不住，不理解也没关系，哪天遇到问题，再来找找有没有合适的方法也不迟。</p>
<ul>
<li>新建/克隆代码库</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git init                                          #当前目录新建一个Git代码库</div><div class="line">git init [project-name]                             #新建一个目录，将其初始化为Git代码库</div><div class="line">git clone [url]                                     #下载一个项目和它的整个代码历史</div><div class="line">git fetch [url]                                     #下载/同步项目到</div></pre></td></tr></table></figure>
<ul>
<li>添加/删除文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git add [file1] [file2] ...                       # 添加指定文件到暂存区</div><div class="line">git add [dir]                                     # 添加指定目录到暂存区，包括子目录</div><div class="line">git add .                                           # 添加当前目录的所有文件到暂存区</div><div class="line">git rm [file1] [file2] ...                       # 删除工作区文件，并且将这次删除放入暂存区</div><div class="line">git rm --cached [file]                           # 停止追踪指定文件，但该文件会保留在工作区</div><div class="line">git mv [file-original] [file-renamed]              # 改名文件，并且将这个改名放入暂存区</div></pre></td></tr></table></figure>
<ul>
<li>代码提交</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git commit -m [message]                          # 提交暂存区所有文件到仓库区，并指定提交说明</div><div class="line">git commit [file1] [file2] ... -m [message]       # 提交暂存区的指定文件到仓库区，并指定提交说明</div><div class="line">git commit -a   # 提交工作区自上次commit之后的变化，直接到仓库区。是git add 和 git commit的组合操作</div><div class="line">git commit -v                                      # 提交时显示所有diff信息</div><div class="line">git commit --amend -m [message]                   # 使用一次新的commit，替代上一次提交</div></pre></td></tr></table></figure>
<ul>
<li>分支</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">git branch                                       # 列出所有本地分支</div><div class="line">git branch -r                                    # 列出所有远程分支</div><div class="line">git branch -a                                     # 列出所有本地分支和远程分支</div><div class="line">git branch [branch-name]                          # 新建一个分支，但依然停留在当前分支</div><div class="line">git checkout -b [branch]                          # 新建一个分支，并切换到该分支</div><div class="line">git branch [branch] [commit]                      # 新建一个分支，指向指定commit</div><div class="line">git checkout [branch-name]                          # 切换到指定分支</div><div class="line">git merge [branch]                                  # 合并指定分支到当前分支</div><div class="line">git branch -d [branch-name]                      # 删除本地分支</div><div class="line">git push origin --delete [branch-name]              # 方法一：删除远程分支</div><div class="line">git branch -dr [remote/branch]                      # 方法二：删除远程分支</div></pre></td></tr></table></figure>
<ul>
<li>撤销</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">git checkout [file]                               # 恢复暂存区的指定文件到工作区（注意区别分支操作中得checkout命令）</div><div class="line">git checkout [commit] [file]                      # 恢复某个commit的指定文件到暂存区和工作区</div><div class="line">git checkout .                                   # 恢复暂存区的所有文件到工作区</div><div class="line">git reset [file]                                  # 重置暂存区的指定文件，与最新的commit保持一致，但工作区不变</div><div class="line">git reset --hard                                    # 重置暂存区与工作区，与最新的commit保持一致</div><div class="line">git reset [commit]                               # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</div><div class="line">git reset --hard [commit]                          # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</div><div class="line">git reset --keep [commit]                           # 重置当前HEAD为指定commit，但保持暂存区和工作区不变</div><div class="line">git revert [commit]                              # 新建一个commit，用来撤销指定commit</div></pre></td></tr></table></figure>
<ul>
<li>标签</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">git tag                                          # 列出所有tag</div><div class="line">git tag [tag]                                     # 在当前commit新建一个tag</div><div class="line">git tag [tag] [commit]                             # 在指定commit新建一个tag</div><div class="line">git tag -d [tag]                                   # 删除本地tag</div><div class="line">git push origin :refs/tags/[tagName]              # 删除远程tag</div><div class="line">git show [tag]                                      # 查看tag信息</div><div class="line">git push [remote] [tag]                          # 提交指定tag</div><div class="line">git push [remote] --tags                          # 提交所有tag</div><div class="line">git checkout -b [branch] [tag]                   # 新建一个分支，指向某个tag</div></pre></td></tr></table></figure>
<ul>
<li>查看日志</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">git status                                     # 显示所有变更文件</div><div class="line">git log                                          # 显示当前分支的版本历史</div><div class="line">git log --stat                                 # 显示当前分支的版本历史，以及发生变更的文件</div><div class="line">git blame [file]                                # 显示指定文件是什么人在什么时间修改过</div><div class="line">git log -p [file]                                # 显示指定文件相关的每一次diff</div><div class="line">git diff                                         # 显示暂存区和工作区的差异</div><div class="line">git diff --cached [commit]                    # 显示暂存区和某个commit的差异</div><div class="line">git diff HEAD                                 # 显示工作区与当前分支最新commit之间的差异</div><div class="line">git show [commit]                                # 显示某次提交的元数据和内容变化</div><div class="line">git show --name-only [commit]                    # 显示某次提交发生变化的文件</div><div class="line">git show [commit]:[filename]                    # 显示某次提交时，某个文件的内容</div><div class="line">git reflog                                    # 显示当前分支的最近几次提交</div></pre></td></tr></table></figure>
<ul>
<li>远程同步</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">git fetch [remote]                            # 下载远程仓库的所有变动到暂存区</div><div class="line">git remote -v                                 # 显示所有远程仓库</div><div class="line">git remote show [remote]                        # 显示某个远程仓库的信息</div><div class="line">git remote add [shortname] [url]                # 增加一个新的远程仓库，并命名</div><div class="line">git pull [remote] [branch]                    # 取回远程仓库的变化，并与本地分支合并</div><div class="line">git push [remote] [branch]                    # 上传本地指定分支到远程仓库</div><div class="line">git push [remote] --force                        # 即使有冲突，强行推送当前分支到远程仓库</div><div class="line">git push [remote] --all                        # 推送所有分支到远程仓库</div></pre></td></tr></table></figure>
<ul>
<li>设置</li>
</ul>
<p>git的配置文件是.gitconfig，支持全局配置和项目配置，全部配置对所有项目有效，用 –global选择指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">git config --list                                  #显示配置</div><div class="line">git config -e [--global]                           #编辑(全局)配置文件</div><div class="line">git config [--global] user.name &quot;xx&quot;               #设置 commit 的用户</div><div class="line">git config [--global] user.email &quot;xx@xx.com&quot;       #设置 commit 的邮箱</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;Git已经成为程序员日常工具之一，那些Git基本的命令，每天都要用的命令你都记住了吗？如果还没的话，笔者整理了一份清单，以备不时之需所用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;三个基本概念&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;工作区(Works
    
    </summary>
    
      <category term="System" scheme="http://czero000.github.io/categories/System/"/>
    
      <category term="Git" scheme="http://czero000.github.io/categories/System/Git/"/>
    
    
      <category term="git" scheme="http://czero000.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>SaltStack-Nodegroup</title>
    <link href="http://czero000.github.io/2016/04/07/saltstack-nodegroup.html"/>
    <id>http://czero000.github.io/2016/04/07/saltstack-nodegroup.html</id>
    <published>2016-04-07T02:57:33.000Z</published>
    <updated>2016-10-19T02:24:14.164Z</updated>
    
    <content type="html"><![CDATA[<p>为了便于管理功能相似的minion，SaltStack提供了分组模式，官方文档：<a href="http://docs.saltstack.com/en/latest/topics/targeting/nodegroups.html" target="_blank" rel="external">http://docs.saltstack.com/en/latest/topics/targeting/nodegroups.html</a><br>Node group为预先在master配置文件中定义的minion组，用来进行批量对minion操作。在master配置文件中，删除<code>default_include: master.d/*.conf</code>注释。</p>
<ul>
<li>编辑配置文件： /etc/salt/master.d/nodegroup.conf</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#####         Node Groups           #####</div><div class="line">##########################################</div><div class="line"># Node groups allow for logical groupings of minion nodes. A group consists of a group</div><div class="line"># name and a compound target.</div><div class="line">nodegroups:</div><div class="line">  minion: &apos;172.16.11.211&apos;</div></pre></td></tr></table></figure>
<ul>
<li>重启master</li>
</ul>
<p>测试通过-N参数在命令行指定运行的节点组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">salt -N minion test.ping</div><div class="line">172.16.11.211:</div><div class="line">    True</div></pre></td></tr></table></figure></p>
<ul>
<li>在top file中增加组分类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">base:</div><div class="line">  minion:</div><div class="line">    - match: nodegroup</div><div class="line">    - apache</div><div class="line">    - ssh</div></pre></td></tr></table></figure>
<p><img src="https://czero000.github.io/images/devops/saltstack/nodegroup.png" alt="nodegroup"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了便于管理功能相似的minion，SaltStack提供了分组模式，官方文档：&lt;a href=&quot;http://docs.saltstack.com/en/latest/topics/targeting/nodegroups.html&quot; target=&quot;_blank&quot; re
    
    </summary>
    
      <category term="运维自动化" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="SaltStack" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/SaltStack/"/>
    
    
      <category term="saltstack" scheme="http://czero000.github.io/tags/saltstack/"/>
    
  </entry>
  
  <entry>
    <title>SaltStack-States</title>
    <link href="http://czero000.github.io/2016/04/07/saltstack-states.html"/>
    <id>http://czero000.github.io/2016/04/07/saltstack-states.html</id>
    <published>2016-04-07T02:53:38.000Z</published>
    <updated>2016-10-19T02:15:36.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SaltStack的state"><a href="#SaltStack的state" class="headerlink" title="SaltStack的state"></a>SaltStack的state</h2><p>SaltStack使用state模块文件进行配置管理，state使用YAML语法编写，其实它也支持python编写。sls(salt state file)文件为SaltStack state模块的核心，sls文件表示一个系统应处于的系统状态，并且有一个简单的格式设置这些数据，称为配置管理。</p>
<ul>
<li><p>It is all just data<br>其实sls文件只是一个数据结构，对于sls文件的深入理解会有助于对salt state的深入理解和应用。sls文件事实上只是一个字典、列表、字符串或者数字。通过对配置进行数据结构化，使其满足开发者的各种需求，写的越多，越易于理解。</p>
</li>
<li><p>The top file<br>所有的state file都可以通过top.sl文件来分配不同的主机使用，这是个整体入口描述，在执行命令的时候，会先检查这个文件，可以看作是基础配置文件</p>
</li>
<li><p>Default data -yaml<br>默认情况下salt表现的数据格式采用最简单的序列化数据格式-YAML，由于不同架构经常使用不同的名称和安装包，apache在红帽系列中是httpd，其他发行版多为apache，salt对于底层服务器管理使用init下的脚本，系统命令名，配置文件等，执行service.get_all函数来获取对应服务器可用的服务名称</p>
</li>
</ul>
<hr>
<h2 id="使用state"><a href="#使用state" class="headerlink" title="使用state"></a>使用state</h2><h3 id="通过命令查看state使用方法"><a href="#通过命令查看state使用方法" class="headerlink" title="通过命令查看state使用方法"></a>通过命令查看state使用方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">// 查看所有states列表</div><div class="line">salt -N minion&apos; sys.list_state_modules</div><div class="line">// 查看指定states的functions</div><div class="line">salt -N &apos;minion&apos; sys.list_state_functions file</div><div class="line">//查看指定states的用法</div><div class="line">salt -N &apos;minion&apos; sys.state_doc file</div></pre></td></tr></table></figure>
<h3 id="通过示例了解state"><a href="#通过示例了解state" class="headerlink" title="通过示例了解state"></a>通过示例了解state</h3><ul>
<li>安装软件包及启动服务</li>
</ul>
<p>由于不同架构经常使用不同的名称和安装包，apache在红帽系列中是httpd，其他发行版多为apache，salt对于底层服务器管理使用init下的脚本，系统命令名，配置文件等，执行service.get_all函数来获取对应服务器可用的服务名称</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="attr">httpd:</span></div><div class="line"><span class="attr">  pkg:</span></div><div class="line"><span class="bullet">    -</span> installed</div><div class="line"><span class="attr">  service:</span></div><div class="line"><span class="bullet">    -</span> running</div><div class="line"><span class="attr">    - require:</span></div><div class="line"><span class="attr">      - pkg:</span> httpd</div></pre></td></tr></table></figure>
<p>这些sls数据确保apache包被安装而且apache服务处于运行状态。<br>第一行：被称为ID，这个ID是将要执行这些命令的名字<br>第二行和第四行：用来声明salt state开始的状态，分别使用包管理和服务管理，这个pkg状态管理，通过本地的软件包管理器进行软件安装，service管理系统守护进程<br>第三行、第五行：是要执行的function，这些函数被定义在pkg和service中，这里标示包会被安装，并且apache守护进行会运行<br>最后一行：require是一个必要的声明，用来定义状态之剑的依赖，他们保证apache服务安装成功后才会启动apache守护进程<br>state和方法可以通过点连接起来，上例和下文相同：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="attr">httpd:</span></div><div class="line">  pkg.installed</div><div class="line">  service.running</div><div class="line"><span class="attr">    - require:</span></div><div class="line"><span class="attr">      - pkg:</span> httpd</div></pre></td></tr></table></figure></p>
<p>在实际配置管理中，需要编写大量state.sls文件。这些文件会有一个top.sls（非必须）文件作为入口文件，负责指定minion调用某些state.sls文件。</p>
<p>将上面的sls保存为init.sls放置在salt://apache目录下，</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">/srv/salt/</div><div class="line">├── apache</div><div class="line">│   └── init.sls</div><div class="line">└── top.sls</div></pre></td></tr></table></figure>
<ul>
<li>添加配置文件和用户</li>
</ul>
<p>​    当建立类似Apache服务器这样的服务时，许多组件需要被安装。apache的配置文件要被管理起来，而且还需要特定的用户和用户</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="attr">httpd:</span></div><div class="line"><span class="attr">  pkg:</span></div><div class="line"><span class="bullet">    -</span> installed</div><div class="line"><span class="attr">  service:</span></div><div class="line"><span class="bullet">    -</span> running</div><div class="line"><span class="attr">    - watch:</span></div><div class="line"><span class="attr">      - pkg:</span> httpd</div><div class="line"><span class="attr">      - file:</span> /etc/httpd/conf/httpd.conf</div><div class="line"><span class="attr">      - user:</span> apache</div><div class="line">  user.present:</div><div class="line"><span class="attr">    - name:</span> apache</div><div class="line"><span class="attr">    - uid:</span> <span class="number">48</span></div><div class="line"><span class="attr">    - gid:</span> <span class="number">48</span></div><div class="line"><span class="attr">    - home:</span> /var/www</div><div class="line"><span class="attr">    - shell:</span> /bin/nologin</div><div class="line"><span class="attr">    - require:</span></div><div class="line"><span class="attr">      - group:</span> apache</div><div class="line">  group.present:</div><div class="line"><span class="attr">    - name:</span> apache</div><div class="line"><span class="attr">    - gid:</span> <span class="number">48</span></div><div class="line"><span class="attr">    - require:</span></div><div class="line"><span class="attr">      - pkg:</span> httpd</div><div class="line">/etc/httpd/conf/httpd.conf:</div><div class="line">  file.managed:</div><div class="line"><span class="attr">    - source:</span> salt://apache/httpd.conf</div><div class="line"><span class="attr">    - user:</span> root</div><div class="line"><span class="attr">    - group:</span> root</div><div class="line"><span class="attr">    - mode:</span> <span class="number">644</span></div></pre></td></tr></table></figure>
<p>​    这个例子扩展了上面，其中包括了一个配置文件、一个用户、一个用户组还有一个新的声明：watch。在service中的require换成了watch，从需要一个软件包改成监视3个state（分别是pkg、file、user）。watch语句和require很相似，都能保证被监视或者需要的state在自己之前执行，但是watch还有其他作用。当被监视的state发生变化时，定义watch语句的state与执行自己的watcher函数，当更新软件包、配置文件或者修改apache用户的uid都会触发service state的watcher函数，在本例子中，service state的watcher会重启apache服务。</p>
<ul>
<li>多个sls文件</li>
</ul>
<p>​    在具有扩展性的SaltStack时，需要不止一个sls，上面的例子中只使用了1个sls文件，多个sls文件可以结合成state tree。sls文件以一定的目录结构分布在master，sls和要发到minion上的文件只是普通文件.</p>
<p>ssh/init.sls</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">::::::::::::::</div><div class="line">init.sls</div><div class="line">::::::::::::::</div><div class="line"><span class="attr">include:</span></div><div class="line"><span class="bullet">  -</span> client</div><div class="line"><span class="bullet">  -</span> server</div><div class="line"></div><div class="line">::::::::::::::</div><div class="line">client.sls</div><div class="line">::::::::::::::</div><div class="line"><span class="attr">openssh-clients:</span></div><div class="line">  pkg.installed</div><div class="line">/etc/ssh/ssh_config:</div><div class="line">  file.managed:</div><div class="line"><span class="attr">    - user:</span> root</div><div class="line"><span class="attr">    - group:</span> root</div><div class="line"><span class="attr">    - mode:</span> <span class="number">644</span></div><div class="line"><span class="attr">    - source:</span> salt://ssh/files/ssh_config</div><div class="line"><span class="attr">    - require:</span></div><div class="line"><span class="attr">      - pkg:</span> openssh-clients</div><div class="line">      </div><div class="line">::::::::::::::</div><div class="line">server.sls</div><div class="line">::::::::::::::</div><div class="line"><span class="attr">include:</span></div><div class="line"><span class="bullet">  -</span> ssh</div><div class="line"><span class="attr">openssh-server:</span></div><div class="line">  pkg.installed</div><div class="line"><span class="attr">sshd:</span></div><div class="line">  service.running:</div><div class="line"><span class="attr">    - require:</span></div><div class="line"><span class="attr">      - pkg:</span> openssh-clients</div><div class="line"><span class="attr">      - pkg:</span> openssh-server</div><div class="line"><span class="attr">      - file:</span> /etc/ssh/sshd_config</div><div class="line">/etc/ssh/sshd_config:</div><div class="line">  file.managed:</div><div class="line"><span class="attr">    - user:</span> root</div><div class="line"><span class="attr">    - group:</span> root</div><div class="line"><span class="attr">    - mode:</span> <span class="number">644</span></div><div class="line"><span class="attr">    - source:</span> salt://ssh/files/sshd_config</div><div class="line"><span class="attr">    - require:</span></div><div class="line"><span class="attr">      - pkg:</span> openssh-server</div></pre></td></tr></table></figure>
<ul>
<li><p>扩展被引用的sls数据</p>
<p>  什么是扩展呢。在ssh/server.sls文件中定义了一个apache通用的服务器，现在需要增加一个带有mod_python模块的apache，不需要重新写sls，可以直接include原来的server.sls，然后增加安装mod_python的state，在apache service的watch列表中增加mod_python即可。<em>**</em></p>
</li>
</ul>
<p>python/mod_ypthon.sls内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">include:  </div><div class="line">- apache</div><div class="line"></div><div class="line">extend:</div><div class="line">  apache:</div><div class="line">    service:</div><div class="line">      - watch: </div><div class="line">        - pkg:mod_python</div><div class="line"></div><div class="line">mod_python:  pkg.installed</div></pre></td></tr></table></figure>
<p>这个例子中，先把apache目录下init.sls文件包含进来（在include一个目录时，salt会自动查找init.sls文件），然后拓展了ID为apache下的service state中的watch列表。也可以在extending中修改下载文件位置。extend是salt 的sls更加灵活。</p>
<ul>
<li><p>理解渲染系统Render System</p>
<p> 因为sls仅是数据，所以不是非要用YAML来表达。salt 默认用YAML，只是因为容易学习和使用，只要提供一个渲染器，sls文件可以以任意格式呈现出来。</p>
</li>
</ul>
<p>​    缺省的渲染系统是yaml_jinja渲染器。yaml_jinja渲染器使用jinjia2模版引擎来处理sls，然后在调用YAML解析。其他可用的渲染其还包括：yaml_mako模版引擎；yaml_wempy，使用Wempy模版引擎；py，使用Python写sls文件；pydsl，建立在python语法基础上的描述语言。</p>
<ul>
<li><p>默认渲染器—yaml_jinja</p>
<p>关于jinjia模板系统使用参考官方稳定：<a href="http://jinja.pocoo.org/docs" target="_blank" rel="external">http://jinja.pocoo.org/docs</a></p>
</li>
</ul>
<p>在基于模板引擎的渲染器，可以从3个组件中获取需要的数据：salt，grains和pilla。在模板文件中，salt对象允许任何salt函数从模板内容进行调用，grains允许grains从模板中访问：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">apache:</div><div class="line">  pkg:</div><div class="line">    - installed</div><div class="line">    &#123;% if grains[ &apos;os&apos; ] == &apos;CentOS&apos; %&#125;</div><div class="line">    - name: httpd</div><div class="line">    &#123;% endif %&#125;</div><div class="line">  service:</div><div class="line">    - running</div><div class="line">    &#123;% if grains[ &apos;os&apos; ] == &apos;CentOS&apos;%&#125;</div><div class="line">    - name: httpd</div><div class="line">    &#123;% endif %&#125;</div><div class="line">    - watch:</div><div class="line">      - pkg: apache</div><div class="line">      - file: /etc/httpd/conf/httpd.conf</div><div class="line">      - user: apache</div><div class="line">  user.present:</div><div class="line">    - name: apache</div><div class="line">    - uid: 48</div><div class="line">    - gid: 48</div><div class="line">    - home: /var/www</div><div class="line">    - shell: /bin/nologin</div><div class="line">    - require:</div><div class="line">      - group: apache</div><div class="line">  group.present:</div><div class="line">    - name: apache</div><div class="line">    - gid: 48</div><div class="line">    - require:</div><div class="line">      - pkg: apache</div><div class="line">/etc/httpd/conf/httpd.conf:</div><div class="line">  file.managed:</div><div class="line">    - source: salt://apache/files/httpd.conf</div><div class="line">    - user: root</div><div class="line">    - group: root</div><div class="line">    - mode: 644</div></pre></td></tr></table></figure>
<p>这个例子很容易理解，用到jinja中的条件结构，如果grains中os表明minion的操作系统是CentOS，那么apache的软件包和服务名应当是httpd。更有意思的例子，用到jinja的循环结构，在设置MooseFS分布式中chunkserver：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">moosefs/chunk.sls：</div><div class="line"><span class="attr">include:</span></div><div class="line"><span class="bullet">    -</span> moosefs</div><div class="line">&#123;% for mnt in salt[<span class="string">'cmd.run'</span>](<span class="string">'ls /dev/data/moose*'</span>).split() %&#125;</div><div class="line">/mnt/moose&#123;&#123; mnt[<span class="bullet">-1</span>] &#125;&#125;:</div><div class="line">  mount.mounted:</div><div class="line"><span class="attr">    - device:</span> &#123;&#123; mnt &#125;&#125;</div><div class="line"><span class="attr">    - fstype:</span> xfs</div><div class="line"><span class="attr">    - mkmnt:</span> <span class="literal">True</span></div><div class="line">  file.directory:</div><div class="line"><span class="attr">    - user:</span> mfs</div><div class="line"><span class="attr">    - group:</span> mfs</div><div class="line"><span class="attr">    - require:</span></div><div class="line"><span class="attr">      - user:</span> mfs</div><div class="line"><span class="attr">      - group:</span> mfs</div><div class="line">&#123;% endfor %&#125;</div><div class="line">/etc/mfshdd.cfg:</div><div class="line">  file.managed:</div><div class="line"><span class="attr">    - source:</span> salt://moosefs/mfshdd.cfg</div><div class="line"><span class="attr">    - user:</span> root</div><div class="line"><span class="attr">    - group:</span> root</div><div class="line"><span class="attr">    - mode:</span> <span class="number">644</span></div><div class="line"><span class="attr">    - template:</span> jinja</div><div class="line"><span class="attr">    - require:</span></div><div class="line"><span class="attr">      - pkg:</span> mfs-chunkserver</div><div class="line"> </div><div class="line">/etc/mfschunkserver.cfg:</div><div class="line">  file.managed:</div><div class="line"><span class="attr">    - source:</span> salt://moosefs/mfschunkserver.cfg</div><div class="line"><span class="attr">    - user:</span> root</div><div class="line"><span class="attr">    - group:</span> root</div><div class="line"><span class="attr">    - mode:</span> <span class="number">644</span></div><div class="line"><span class="attr">    - template:</span> jinja</div><div class="line"><span class="attr">    - require:</span></div><div class="line"><span class="attr">      - pkg:</span> mfs-chunkserver</div><div class="line"> </div><div class="line"><span class="attr">mfs-chunkserver:</span></div><div class="line"><span class="attr">  pkg:</span></div><div class="line"><span class="bullet">    -</span> installed</div><div class="line"><span class="attr">mfschunkserver:</span></div><div class="line"><span class="attr">  service:</span></div><div class="line"><span class="bullet">    -</span> running</div><div class="line"><span class="attr">    - require:</span></div><div class="line">&#123;% for mnt in salt[<span class="string">'cmd.run'</span>](<span class="string">'ls /dev/data/moose*'</span>) %&#125;</div><div class="line"><span class="attr">      - mount:</span> /mnt/moose&#123;&#123; mnt[<span class="bullet">-1</span>] &#125;&#125;</div><div class="line"><span class="attr">      - file:</span> /mnt/moose&#123;&#123; mnt[<span class="bullet">-1</span>] &#125;&#125;</div><div class="line">&#123;% endfor %&#125;</div><div class="line"><span class="attr">      - file:</span> /etc/mfschunkserver.cfg</div><div class="line"><span class="attr">      - file:</span> /etc/mfshdd.cfg</div><div class="line"><span class="attr">      - file:</span> /var/lib/mfs</div></pre></td></tr></table></figure>
<p>这个例子展示了jinja的强大之处，多个for循环用来动态的检查并挂载磁盘，并多次使用salt cmd.run执行模块执行shell命令。</p>
<ul>
<li><p>运行和调用salt states</p>
<p>一旦写好sls文件，就应该测试，以保证能够正常工作，调用这些规则，只需要在命令行中执行 salt * state.highstate。如果返回的只有主机名，很可能是sls文件存在问题，在minion，使用salt-call命令执行 salt-call state.highstate -l debug来调试输出的作物信息，亦可以在前台执行salt-minion -l debug</p>
</li>
</ul>
<h3 id="state多环境配置"><a href="#state多环境配置" class="headerlink" title="state多环境配置"></a>state多环境配置</h3><ul>
<li>master</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">file_roots:</div><div class="line">  base:</div><div class="line">    - /srv/salt/base</div><div class="line">  dev:</div><div class="line">    - /srv/salt/dev</div></pre></td></tr></table></figure>
<ul>
<li>通过命令执行不同环境state</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">salt -N &apos;minion&apos; state.sls saltenv=&apos;dev&apos;</div><div class="line">salt -N &apos;minion&apos; state.sls saltenv=&apos;base&apos;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;SaltStack的state&quot;&gt;&lt;a href=&quot;#SaltStack的state&quot; class=&quot;headerlink&quot; title=&quot;SaltStack的state&quot;&gt;&lt;/a&gt;SaltStack的state&lt;/h2&gt;&lt;p&gt;SaltStack使用state模块
    
    </summary>
    
      <category term="运维自动化" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="SaltStack" scheme="http://czero000.github.io/categories/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96/SaltStack/"/>
    
    
      <category term="saltstack" scheme="http://czero000.github.io/tags/saltstack/"/>
    
  </entry>
  
</feed>
